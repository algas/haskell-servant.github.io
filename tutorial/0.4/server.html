<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Serving an API - haskell-servant</title>
        <link rel="stylesheet" type="text/css" href="../../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../../">servant</a>
            </div>
            <div id="navigation">
                <a href="../../">Home</a>
                <a href="../../blog.html">Blog</a>
                <a href="../../tutorial">Tutorial</a>
                <a href="../../tips.html">Tips and tricks</a>
                <a href="../../talks.html">Talks</a>
                <a href="https://github.com/haskell-servant/servant">Github</a>
            </div>
        </div>

        <div id="content">
            <h1>Serving an API</h1>

            <div id="toc"><h3>Table of contents</h3><ul>
<li><a href="#a-first-example">A first example</a></li>
<li><a href="#more-endpoints">More endpoints</a></li>
<li><a href="#from-combinators-to-handler-arguments">From combinators to handler arguments</a></li>
<li><a href="#the-fromtexttotext-classes">The <code>FromText</code>/<code>ToText</code> classes</a></li>
<li><a href="#using-content-types-with-your-data-types">Using content-types with your data types</a><ul>
<li><a href="#the-truth-behind-json">The truth behind <code>JSON</code></a></li>
<li><a href="#case-studies-servant-blaze-and-servant-lucid">Case-studies: <em>servant-blaze</em> and <em>servant-lucid</em></a></li>
</ul></li>
<li><a href="#the-eithert-servanterr-io-monad">The <code>EitherT ServantErr IO</code> monad</a><ul>
<li><a href="#performing-io">Performing IO</a></li>
<li><a href="#failing-through-servanterr">Failing, through <code>ServantErr</code></a></li>
</ul></li>
<li><a href="#response-headers">Response headers</a></li>
<li><a href="#serving-static-files">Serving static files</a></li>
<li><a href="#nested-apis">Nested APIs</a></li>
<li><a href="#using-another-monad-for-your-handlers">Using another monad for your handlers</a><ul>
<li><a href="#natural-transformations">Natural transformations</a></li>
<li><a href="#enter-enter">Enter <code>enter</code></a></li>
</ul></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul></div>
<p>型レベル結合子とAPIの種類についての説明はこのくらいにして、いよいよウェブサービスに進みましょう。</p>
<p>このガイドに書いてあることを試してみるには、下記をコマンドを入力します。</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">cabal</span> get servant-examples
<span class="kw">cd</span> servant-examples-<span class="kw">&lt;</span>VERSION<span class="kw">&gt;</span>
<span class="kw">cabal</span> sandbox init
<span class="kw">cabal</span> install --dependencies-only
<span class="kw">cabal</span> configure <span class="kw">&amp;&amp;</span> <span class="kw">cabal</span> build</code></pre></div>
<p>上記のコマンドは <code>tutorial</code> 実行ファイルを <code>dist/build/tutorial</code> というパスに生成します。 コマンドライン引数に対応するサンプル番号を入れて実行します。</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">dist/build/tutorial/tutorial</span>
<span class="kw">Usage</span>:   tutorial N
        <span class="kw">where</span> N is the number of the example you want to run.</code></pre></div>
<section id="a-first-example" class="level1">
<h1>A first example</h1>
<p>APIを作る基礎知識は身につけたので、最初のウェブサービスを書いてみましょう。</p>
<p>この章のソースはliterate haskell fileで書いてあります。 いくつかの言語拡張とライブラリインポートが必要です。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE DeriveGeneric #-}</span>
<span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>
<span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>

<span class="kw">module</span> <span class="dt">Server</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Monad.IO.Class</span>
<span class="kw">import </span><span class="dt">Control.Monad.Reader</span>
<span class="kw">import </span><span class="dt">Control.Monad.Trans.Either</span>
<span class="kw">import </span><span class="dt">Data.Aeson</span>
<span class="kw">import </span><span class="dt">Data.Aeson.Types</span>
<span class="kw">import </span><span class="dt">Data.Attoparsec.ByteString</span>
<span class="kw">import </span><span class="dt">Data.ByteString</span> (<span class="dt">ByteString</span>)
<span class="kw">import </span><span class="dt">Data.Int</span>
<span class="kw">import </span><span class="dt">Data.List</span>
<span class="kw">import </span><span class="dt">Data.String.Conversions</span>
<span class="kw">import </span><span class="dt">Data.Time.Calendar</span>
<span class="kw">import </span><span class="dt">GHC.Generics</span>
<span class="kw">import </span><span class="dt">Lucid</span>
<span class="kw">import </span><span class="dt">Network.HTTP.Media</span> ((//), (/:))
<span class="kw">import </span><span class="dt">Network.Wai</span>
<span class="kw">import </span><span class="dt">Network.Wai.Handler.Warp</span>
<span class="kw">import </span><span class="dt">Servant</span>
<span class="kw">import </span><span class="dt">System.Directory</span>
<span class="kw">import </span><span class="dt">Text.Blaze</span>
<span class="kw">import </span><span class="dt">Text.Blaze.Html.Renderer.Utf8</span>
<span class="kw">import qualified</span> <span class="dt">Data.Aeson.Parser</span>
<span class="kw">import qualified</span> <span class="dt">Text.Blaze.Html</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></code></pre></div>
<p><strong>重要</strong>: <code>Servant</code> モジュールは <em>servant-server</em> パッケージにあります。 ウェブサーバを実行したり幾つかのAPIを実装しています。 <code>Servant</code> モジュールは <em>servant</em> パッケージからすべての型をエクスポートしなおしています。 リクエストハンドラをウェブサービスにするために必要なすべてのAPIが定義されています。 つまり、依存パッケージに <em>servant-server</em> を追加して <code>Servant</code> をインポートするだけで うまくいくので他の心配は要らないということです。</p>
<p>次のAPIからサーバを書きます。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">UserAPI1</span> <span class="fu">=</span> <span class="st">&quot;users&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [User]</span></code></pre></div>
<p>これは <code>/users</code> へ GET リクエストを送ると何が見えるかを示しています。</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">[ {<span class="st">&quot;name&quot;</span>: <span class="st">&quot;Isaac Newton&quot;</span>, <span class="st">&quot;age&quot;</span>: <span class="dv">372</span>, <span class="st">&quot;email&quot;</span>: <span class="st">&quot;isaac@newton.co.uk&quot;</span>, <span class="st">&quot;registration_date&quot;</span>: <span class="st">&quot;1683-03-01&quot;</span>}
, {<span class="st">&quot;name&quot;</span>: <span class="st">&quot;Albert Einstein&quot;</span>, <span class="st">&quot;age&quot;</span>: <span class="dv">136</span>, <span class="st">&quot;email&quot;</span>: <span class="st">&quot;ae@mc2.org&quot;</span>, <span class="st">&quot;registration_date&quot;</span>: <span class="st">&quot;1905-12-01&quot;</span>}
]</code></pre></div>
<p><code>User</code> データ型を定義して、インスタンスを書いてみましょう。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">User</span> <span class="fu">=</span> <span class="dt">User</span>
  {<span class="ot"> name ::</span> <span class="dt">String</span>
  ,<span class="ot"> age ::</span> <span class="dt">Int</span>
  ,<span class="ot"> email ::</span> <span class="dt">String</span>
  ,<span class="ot"> registration_date ::</span> <span class="dt">Day</span>
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Generic</span>)

<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">User</span></code></pre></div>
<p>何も楽しくはありませんが、2人のユーザのリストを定義しましょう。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">users1 ::</span> [<span class="dt">User</span>]
users1 <span class="fu">=</span>
  [ <span class="dt">User</span> <span class="st">&quot;Isaac Newton&quot;</span>    <span class="dv">372</span> <span class="st">&quot;isaac@newton.co.uk&quot;</span> (fromGregorian <span class="dv">1683</span>  <span class="dv">3</span> <span class="dv">1</span>)
  , <span class="dt">User</span> <span class="st">&quot;Albert Einstein&quot;</span> <span class="dv">136</span> <span class="st">&quot;ae@mc2.org&quot;</span>         (fromGregorian <span class="dv">1905</span> <span class="dv">12</span> <span class="dv">1</span>)
  ]</code></pre></div>
<p>APIの型も書きましょう。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">UserAPI1</span> <span class="fu">=</span> <span class="st">&quot;users&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [User]</span></code></pre></div>
<p>このようなAPIに対するリクエストを処理するウェブサービスを実際に書いてみましょう。このAPIは 非常に単純で、1つのエンドポイントに絞られています。ウェブアプリケーションの型は <code>Server</code> という <em>type family</em> を通して API の型から決まります。(type family は入力と戻り値の型を 型として持つ関数です。) <code>Server</code> type family は大量のリスエストハンドラが持つ正しい型を 対応するAPIの型から判別してくれます。</p>
<p><code>Server</code> type family について知るべきことは、それが裏でひっそりとルーティングを制御 しているので、ビジネスロジックに専念できるということです。また、個々のエンドポイントごと にハンドラがデフォルトでは <code>EitherT ServantErr IO</code> モナド内で動きます。モナド内で返る 値の型は、対応するエンドポイント使われるHTTPメソッド結合子の二番目の引数と同じでなければ なりません。前述のAPIの場合、<code>EitherT ServantErr IO [User]</code> 型のハンドラを用意しなけ ればなりません。モナドが手に入ったので、ユーザ一覧を返してみましょう。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">server1 ::</span> <span class="dt">Server</span> <span class="dt">UserAPI1</span>
server1 <span class="fu">=</span> return users1</code></pre></div>
<p>よくできました。 <a href="http://hackage.haskell.org/package/wai">wai</a> と <a href="http://hackage.haskell.org/package/warp">warp</a> を使えば、<code>server</code> を実際のウェブサーバにすることができます。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">userAPI ::</span> <span class="dt">Proxy</span> <span class="dt">UserAPI1</span>
userAPI <span class="fu">=</span> <span class="dt">Proxy</span>

<span class="co">-- 'serve' は servant から与えられたもので WAI アプリケーションと接続します。</span>
<span class="co">-- &quot;抽象的な&quot; ウェブアプリケーションであってウェブサーバのことではありません。</span>
<span class="ot">app1 ::</span> <span class="dt">Application</span>
app1 <span class="fu">=</span> serve userAPI server1</code></pre></div>
<p><code>userAPI</code> は悲しいかな、ボイラープレートです。(型推論の助けが必要です) しかし、これ以外にボイラープレートはありません。</p>
<p>これで 8081 ポートで動くウェブサービスができました！</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> run <span class="dv">8081</span> app1</code></pre></div>
<p>これを1つのファイルに書くか、<a href="http://github.com/haskell-servant/servant">servant’s repo</a> を取ってきて <em>servant-examples</em> ディレクトリを見てみましょう。コードは <em>tutorial/T1.hs</em> に あります。<code>dist/build/tutorial/tutorial 1</code> コマンドで動作します。</p>
<p>もし動かせたら、ウェブブラウザか curl で <code>http://localhost:8081/users</code> を見てみましょう。</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">curl</span> http://localhost:8081/users
[{<span class="st">&quot;email&quot;</span>:<span class="st">&quot;isaac@newton.co.uk&quot;</span>,<span class="st">&quot;registration_date&quot;</span>:<span class="st">&quot;1683-03-01&quot;</span>,<span class="st">&quot;age&quot;</span>:<span class="kw">372</span>,<span class="st">&quot;name&quot;</span>:<span class="st">&quot;Isaac Newton&quot;</span>},{<span class="st">&quot;email&quot;</span>:<span class="st">&quot;ae@mc2.org&quot;</span>,<span class="st">&quot;registration_date&quot;</span>:<span class="st">&quot;1905-12-01&quot;</span>,<span class="st">&quot;age&quot;</span>:<span class="kw">136</span>,<span class="st">&quot;name&quot;</span>:<span class="st">&quot;Albert Einstein&quot;</span>}]</code></pre></div>
</section>
<section id="more-endpoints" class="level1">
<h1>More endpoints</h1>
<p>1つ以上のエンドポイントが必要な時は次のようにしましょう。JSONエンコードされたユーザ情報を見るために <code>/albert</code> と <code>/isaac</code> を追加します。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">UserAPI2</span> <span class="fu">=</span> <span class="st">&quot;users&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [User]</span>
           <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;albert&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] User</span>
           <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;isaac&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] User</span></code></pre></div>
<p>それに合わせて、コードも少し直します。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">isaac ::</span> <span class="dt">User</span>
isaac <span class="fu">=</span> <span class="dt">User</span> <span class="st">&quot;Isaac Newton&quot;</span> <span class="dv">372</span> <span class="st">&quot;isaac@newton.co.uk&quot;</span> (fromGregorian <span class="dv">1683</span> <span class="dv">3</span> <span class="dv">1</span>)

<span class="ot">albert ::</span> <span class="dt">User</span>
albert <span class="fu">=</span> <span class="dt">User</span> <span class="st">&quot;Albert Einstein&quot;</span> <span class="dv">136</span> <span class="st">&quot;ae@mc2.org&quot;</span> (fromGregorian <span class="dv">1905</span> <span class="dv">12</span> <span class="dv">1</span>)

<span class="ot">users2 ::</span> [<span class="dt">User</span>]
users2 <span class="fu">=</span> [isaac, albert]</code></pre></div>
<p><code>UserAPI</code> の中で <code>:&lt;|&gt;</code> を使ってエンドポイントを分けたように、ハンドラも <code>:&lt;|&gt;</code> を使って分けます。 ただし、API の type で宣言したのと同じ順番で並べなければなりません。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">server2 ::</span> <span class="dt">Server</span> <span class="dt">UserAPI2</span>
server2 <span class="fu">=</span> return users2
     <span class="fu">:&lt;|&gt;</span> return albert
     <span class="fu">:&lt;|&gt;</span> return isaac</code></pre></div>
<p>これで完成です！ この例題は <code>dist/build/tutorial/tutorial 2</code> で実行できます。 <code>/users</code>, <code>/albert</code>, <code>/isaac</code> で確認してみましょう。</p>
</section>
<section id="from-combinators-to-handler-arguments" class="level1">
<h1>From combinators to handler arguments</h1>
<p>それで、簡単にちょっとしたウェブサービスを書けるようになったが、上記の2つはどちらも servant にある “変な”結合子は使っていない。とにかく <code>QueryParam</code>, <code>Capture</code>, <code>ReqBody</code> を使ってみよう。 この項目では、エンドポイントにあるこれらの結合子が、どのようにして対応するハンドラに適切な型を持つ引数を 自動的に受け取らせるかが書いてあります。URLキャプチャやクエリストリングパラメータ、JSONへのデータ変換 などを調べる手間を心配するは必要はありません。心配無用です。</p>
<p>以下のデータ型と関数を使ってサーバの <code>API</code> を実装しましょう。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">API</span> <span class="fu">=</span> <span class="st">&quot;position&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;x&quot;</span> <span class="dt">Int</span> <span class="fu">:&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;y&quot;</span> <span class="dt">Int</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] Position</span>
      <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;hello&quot;</span> <span class="fu">:&gt;</span> <span class="dt">QueryParam</span> <span class="st">&quot;name&quot;</span> <span class="dt">String</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] HelloMessage</span>
      <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;marketing&quot;</span> <span class="fu">:&gt;</span> <span class="dt">ReqBody</span> <span class="ch">'[JSON] ClientInfo :&gt; Post '</span>[<span class="dt">JSON</span>] <span class="dt">Email</span>

<span class="kw">data</span> <span class="dt">Position</span> <span class="fu">=</span> <span class="dt">Position</span>
  {<span class="ot"> x ::</span> <span class="dt">Int</span>
  ,<span class="ot"> y ::</span> <span class="dt">Int</span>
  } <span class="kw">deriving</span> <span class="dt">Generic</span>

<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Position</span>

<span class="kw">newtype</span> <span class="dt">HelloMessage</span> <span class="fu">=</span> <span class="dt">HelloMessage</span> {<span class="ot"> msg ::</span> <span class="dt">String</span> }
  <span class="kw">deriving</span> <span class="dt">Generic</span>

<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">HelloMessage</span>

<span class="kw">data</span> <span class="dt">ClientInfo</span> <span class="fu">=</span> <span class="dt">ClientInfo</span>
  {<span class="ot"> clientName ::</span> <span class="dt">String</span>
  ,<span class="ot"> clientEmail ::</span> <span class="dt">String</span>
  ,<span class="ot"> clientAge ::</span> <span class="dt">Int</span>
  ,<span class="ot"> clientInterestedIn ::</span> [<span class="dt">String</span>]
  } <span class="kw">deriving</span> <span class="dt">Generic</span>

<span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">ClientInfo</span>
<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">ClientInfo</span>

<span class="kw">data</span> <span class="dt">Email</span> <span class="fu">=</span> <span class="dt">Email</span>
  {<span class="ot"> from ::</span> <span class="dt">String</span>
  ,<span class="ot"> to ::</span> <span class="dt">String</span>
  ,<span class="ot"> subject ::</span> <span class="dt">String</span>
  ,<span class="ot"> body ::</span> <span class="dt">String</span>
  } <span class="kw">deriving</span> <span class="dt">Generic</span>

<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Email</span>

<span class="ot">emailForClient ::</span> <span class="dt">ClientInfo</span> <span class="ot">-&gt;</span> <span class="dt">Email</span>
emailForClient c <span class="fu">=</span> <span class="dt">Email</span> from' to' subject' body'

  <span class="kw">where</span> from'    <span class="fu">=</span> <span class="st">&quot;great@company.com&quot;</span>
        to'      <span class="fu">=</span> clientEmail c
        subject' <span class="fu">=</span> <span class="st">&quot;Hey &quot;</span> <span class="fu">++</span> clientName c <span class="fu">++</span> <span class="st">&quot;, we miss you!&quot;</span>
        body'    <span class="fu">=</span> <span class="st">&quot;Hi &quot;</span> <span class="fu">++</span> clientName c <span class="fu">++</span> <span class="st">&quot;,\n\n&quot;</span>
                <span class="fu">++</span> <span class="st">&quot;Since you've recently turned &quot;</span> <span class="fu">++</span> show (clientAge c)
                <span class="fu">++</span> <span class="st">&quot;, have you checked out our latest &quot;</span>
                <span class="fu">++</span> intercalate <span class="st">&quot;, &quot;</span> (clientInterestedIn c)
                <span class="fu">++</span> <span class="st">&quot; products? Give us a visit!&quot;</span></code></pre></div>
<p>ハンドラの3つのエンドポイントを実装します。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">server3 ::</span> <span class="dt">Server</span> <span class="dt">API</span>
server3 <span class="fu">=</span> position
     <span class="fu">:&lt;|&gt;</span> hello
     <span class="fu">:&lt;|&gt;</span> marketing

  <span class="kw">where</span><span class="ot"> position ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> <span class="dt">Position</span>
        position x y <span class="fu">=</span> return (<span class="dt">Position</span> x y)

<span class="ot">        hello ::</span> <span class="dt">Maybe</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> <span class="dt">HelloMessage</span>
        hello mname <span class="fu">=</span> return <span class="fu">.</span> <span class="dt">HelloMessage</span> <span class="fu">$</span> <span class="kw">case</span> mname <span class="kw">of</span>
          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="st">&quot;Hello, anonymous coward&quot;</span>
          <span class="dt">Just</span> n  <span class="ot">-&gt;</span> <span class="st">&quot;Hello, &quot;</span> <span class="fu">++</span> n

<span class="ot">        marketing ::</span> <span class="dt">ClientInfo</span> <span class="ot">-&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> <span class="dt">Email</span>
        marketing clientinfo <span class="fu">=</span> return (emailForClient clientinfo)</code></pre></div>
<p>上記を見てください。ハンドラの型は必要な形に変わっています。 特に注目すべきは以下の箇所です。</p>
<ul>
<li><code>Capture &quot;something&quot; a</code> は 型 <code>a</code> の引数を持ちます (<code>position</code> の箇所です)</li>
<li><code>QueryParam &quot;something&quot; a</code> 型 <code>Maybe a</code> の引数を持ちます (エンドポイントは クエリ文字列パラメータなしでアクセスできるので、ハンドラにパラメータが必ずしも必要 ではないことを明示できます。</li>
<li><code>ReqBody contentTypeList a</code> は 型 <code>a</code> の引数を持ちます。</li>
</ul>
<p>以上です。 この例題は <code>dist/build/tutorial/tutorial 3</code> で実行できます。</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">curl</span> http://localhost:8081/position/1/2
<span class="dt">{&quot;x&quot;:1,&quot;y&quot;:2}</span>
$ <span class="kw">curl</span> http://localhost:8081/hello
{<span class="st">&quot;msg&quot;</span>:<span class="st">&quot;Hello, anonymous coward&quot;</span>}
$ <span class="kw">curl</span> http://localhost:8081/hello?name=Alp
{<span class="st">&quot;msg&quot;</span>:<span class="st">&quot;Hello, Alp&quot;</span>}
$ <span class="kw">curl</span> -X POST -d <span class="st">'{&quot;name&quot;:&quot;Alp Mestanogullari&quot;, &quot;email&quot; : &quot;alp@foo.com&quot;, &quot;age&quot;: 25, &quot;interested_in&quot;: [&quot;haskell&quot;, &quot;mathematics&quot;]}'</span> -H <span class="st">'Accept: application/json'</span> -H <span class="st">'Content-type: application/json'</span> http://localhost:8081/marketing
{<span class="st">&quot;subject&quot;</span>:<span class="st">&quot;Hey Alp Mestanogullari, we miss you!&quot;</span>,<span class="st">&quot;body&quot;</span>:<span class="st">&quot;Hi Alp Mestanogullari,\n\nSince you've recently turned 25, have you checked out our latest haskell, mathematics products? Give us a visit!&quot;</span>,<span class="st">&quot;to&quot;</span>:<span class="st">&quot;alp@foo.com&quot;</span>,<span class="st">&quot;from&quot;</span>:<span class="st">&quot;great@company.com&quot;</span>}</code></pre></div>
<p>参考までに、<em>servant</em> の結合子の一覧、引数からハンドラへの変換、引数の型についてまとめました。</p>
<blockquote>
<ul>
<li><code>Delete</code>, <code>Get</code>, <code>Patch</code>, <code>Post</code>, <code>Put</code>: これらは引数にはならず、ハンドラの戻り値の型を示します。通常は <code>EitherT ServantErr IO &lt;something&gt;</code> のように表されます。</li>
<li><code>Capture &quot;something&quot; a</code> は <code>a</code> 型の引数となります.</li>
<li><code>QueryParam &quot;something&quot; a</code>, <code>MatrixParam &quot;something&quot; a</code>, <code>Header &quot;something&quot; a</code> はすべて <code>Maybe a</code> 型の引数となります。クライアントから渡される値がなくても大丈夫です。</li>
<li><code>QueryFlag &quot;something&quot;</code> と <code>MatrixFlag &quot;something&quot;</code> は <code>Bool</code> 型の引数になります.</li>
<li><code>QueryParams &quot;something&quot; a</code> と <code>MatrixParams &quot;something&quot; a</code> は <code>[a]</code> 型の引数となります。</li>
<li><code>ReqBody contentTypes a</code> は <code>a</code> 型の引数となります.</li>
</ul>
</blockquote>
</section>
<section id="the-fromtexttotext-classes" class="level1">
<h1>The <code>FromText</code>/<code>ToText</code> classes</h1>
<p>servant は URL から <code>Int</code> にデコードしたり、リクエストボディから <code>ClientInfo</code> の値をデコードしたりする 方法をどうやって知るのでしょうか？ この章と次の章でそれが明らかになります。</p>
<p><code>Capture</code> と <code>QueryParam</code> は URL 内にテキストで書かれています。<code>Header</code> はリクエストの メタデータ内にヘッダ名と値が同じようにテキストで書かれています。servant で <code>FromText</code> と <code>ToText</code> という2つの型クラスが提供されている理由は、これら各々のテキストから値または値からテキストへと変換できる ようにするためです。定義は以下のとおりです：</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">FromText</span> a <span class="kw">where</span>
<span class="ot">  fromText ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a

<span class="kw">class</span> <span class="dt">ToText</span> a <span class="kw">where</span>
<span class="ot">  toText ::</span> a <span class="ot">-&gt;</span> <span class="dt">Text</span></code></pre></div>
<p><code>Capture</code> や <code>QueryParam</code>, <code>Header</code> などは <code>FromText</code> インスタンスを提供してあげれば、 正しく動作します。<em>servant</em> は十分な数のインスタンスを提供していますが、自分で定義する場合の 例を以下に示します。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- 典型的な enumeration</span>
<span class="kw">data</span> <span class="dt">Direction</span>
  <span class="fu">=</span> <span class="dt">Up</span>
  <span class="fu">|</span> <span class="dt">Down</span>
  <span class="fu">|</span> <span class="dt">Left</span>
  <span class="fu">|</span> <span class="dt">Right</span>

<span class="kw">instance</span> <span class="dt">FromText</span> <span class="dt">Direction</span> <span class="kw">where</span>
  <span class="co">-- {-# LANGUAGE OverloadedStrings #-} が必要</span>
  fromText <span class="st">&quot;up&quot;</span>    <span class="fu">=</span> <span class="dt">Just</span> <span class="dt">Up</span>
  fromText <span class="st">&quot;down&quot;</span>  <span class="fu">=</span> <span class="dt">Just</span> <span class="dt">Down</span>
  fromText <span class="st">&quot;left&quot;</span>  <span class="fu">=</span> <span class="dt">Just</span> <span class="dt">Server.Left</span>
  fromText <span class="st">&quot;right&quot;</span> <span class="fu">=</span> <span class="dt">Just</span> <span class="dt">Server.Right</span>
  fromText       _ <span class="fu">=</span> <span class="dt">Nothing</span>

<span class="kw">instance</span> <span class="dt">ToText</span> <span class="dt">Direction</span> <span class="kw">where</span>
  toText <span class="dt">Up</span>           <span class="fu">=</span> <span class="st">&quot;up&quot;</span>
  toText <span class="dt">Down</span>         <span class="fu">=</span> <span class="st">&quot;down&quot;</span>
  toText <span class="dt">Server.Left</span>  <span class="fu">=</span> <span class="st">&quot;left&quot;</span>
  toText <span class="dt">Server.Right</span> <span class="fu">=</span> <span class="st">&quot;right&quot;</span>

<span class="kw">newtype</span> <span class="dt">UserId</span> <span class="fu">=</span> <span class="dt">UserId</span> <span class="dt">Int64</span>
  <span class="kw">deriving</span> (<span class="dt">FromText</span>, <span class="dt">ToText</span>)</code></pre></div>
<p>もしくは以下のようにも書けます。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">FromText</span> <span class="dt">UserId</span> <span class="kw">where</span>
  fromText <span class="fu">=</span> fmap <span class="dt">UserId</span> fromText

<span class="kw">instance</span> <span class="dt">ToText</span> <span class="dt">UserId</span> <span class="kw">where</span>
  toText (<span class="dt">UserId</span> i) <span class="fu">=</span> toText i</code></pre></div>
<p>これらの class について言うことは他に何もありません。<code>Capture</code>, <code>QueryParam</code>, <code>QueryParams</code>, <code>MatrixParam</code>, <code>MatrixParams</code>, <code>Header</code> そして自作の型を使う時にはそれらのインスタンスが必要です。 <code>FromText</code> インスタンスはサーバサイドで、<code>ToText</code> インスタンスは <em>servant-client</em> でのみ使います。 servant-client については <a href="../../tutorial/client.html">section about deriving haskell functions to query an API</a> に書きます。</p>
</section>
<section id="using-content-types-with-your-data-types" class="level1">
<h1>Using content-types with your data types</h1>
<p>JSON からリクエストボディをデコードするまたはレスポンスから JSON をエンコードするときにも 同じ原則が使われます (JSON は実行可能な例題で、任意の content-type で使うことができます)</p>
<p>この章では <em>servant</em> が提供する2つの型クラスを紹介します。</p>
<section id="the-truth-behind-json" class="level2">
<h2>The truth behind <code>JSON</code></h2>
<p><code>JSON</code> とは一体何でしょうか？ JSON は <em>servant</em> が提供する他の2つの content-type と同じように ダンプデータ型です。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">JSON</span>
<span class="kw">data</span> <span class="dt">PlainText</span>
<span class="kw">data</span> <span class="dt">FormUrlEncoded</span>
<span class="kw">data</span> <span class="dt">OctetStream</span></code></pre></div>
<p>明らかにこれは <code>JSON</code> になるためのすべてではないし、全く要領を得ないとも言える。<em>servant</em> 内の 多くのデータ型と同様に、<code>JSON</code> は JSON フォーマットへエンコードする特別なシンボルでもあります。 この関係をつなぐ方法は2つのステップに分けられます。</p>
<p>初めのステップは <code>JSON</code> または自前の content-type を表すのに適した <a href="https://hackage.haskell.org/package/http-media-0.6.2/docs/Network-HTTP-Media.html"><code>MediaType</code></a> を提供することです。このリンクから haddock を生成するには、適切な関数を使って <code>application/json</code> を 指定しなければなりません。この場合には、<code>(//) :: ByteString -&gt; ByteString -&gt; MediaType</code> を 使いましょう。正しく <code>MediaType</code> を指定するには、<code>Accept</code> クラスのインスタンスを書きましょう。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- for reference:</span>
<span class="kw">class</span> <span class="dt">Accept</span> ctype <span class="kw">where</span>
<span class="ot">    contentType   ::</span> <span class="dt">Proxy</span> ctype <span class="ot">-&gt;</span> <span class="dt">MediaType</span>

<span class="kw">instance</span> <span class="dt">Accept</span> <span class="dt">JSON</span> <span class="kw">where</span>
    contentType _ <span class="fu">=</span> <span class="st">&quot;application&quot;</span> <span class="fu">//</span> <span class="st">&quot;json&quot;</span></code></pre></div>
<p>2番目のステップは <code>MimeRender</code> と <code>MimeUnrender</code> クラスを中心としたことです。 これらのクラスは値を自前の content-type に変換する方法を示します。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Accept</span> ctype <span class="ot">=&gt;</span> <span class="dt">MimeRender</span> ctype a <span class="kw">where</span>
<span class="ot">    mimeRender  ::</span> <span class="dt">Proxy</span> ctype <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ByteString</span>
    <span class="co">-- alternatively readable as:</span>
<span class="ot">    mimeRender  ::</span> <span class="dt">Proxy</span> ctype <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">ByteString</span>)</code></pre></div>
<p>content-type と user type を与えると、<code>MimeRender</code>は<code>a</code>型の値を遅延<code>ByteString</code>型 にエンコードする機能を提供します。</p>
<p><code>JSON</code> の場合は簡単です。任意の <code>a</code> 型に対する <code>ToJSON</code> インスタンスにおいて、 <code>Data.Aeson.encode</code> を使うとその型の値を JSON に変換できます。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">ToJSON</span> a <span class="ot">=&gt;</span> <span class="dt">MimeRender</span> <span class="dt">JSON</span> a <span class="kw">where</span>
  mimeRender _ <span class="fu">=</span> encode</code></pre></div>
<p><code>MimeUnrender</code> クラスを使うと、遅延<code>ByteString</code>から値を抽出できる、もしくは エラー文字列を出して失敗します。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Accept</span> ctype <span class="ot">=&gt;</span> <span class="dt">MimeUnrender</span> ctype a <span class="kw">where</span>
<span class="ot">    mimeUnrender ::</span> <span class="dt">Proxy</span> ctype <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> a
    <span class="co">-- alternatively:</span>
<span class="ot">    mimeUnrender ::</span> <span class="dt">Proxy</span> ctype <span class="ot">-&gt;</span> (<span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> a)</code></pre></div>
<p><code>Data.Aeson.eitherDecode</code> を使えば either についてすることはほとんどありません。 しかし、トップレベル JSON の値として配列かオブジェクトしか許されておらず、“JSONドキュメント” のトップレベルで任意の型のJSONの値を使うことができる <em>aeson</em> や <em>attoparsec</em> を使って ちょっとした関数を書くほうがよく使われています。以下に定義を示します。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">eitherDecodeLenient ::</span> <span class="dt">FromJSON</span> a <span class="ot">=&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> a
eitherDecodeLenient input <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">    v ::</span> <span class="dt">Value</span> <span class="ot">&lt;-</span> parseOnly (Data.Aeson.Parser.value <span class="fu">&lt;*</span> endOfInput) (cs input)
    parseEither parseJSON v</code></pre></div>
<p>以下の関数はまさに <code>MimeUnrender</code> インスタンスに必要なものです。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">FromJSON</span> a <span class="ot">=&gt;</span> <span class="dt">MimeUnrender</span> <span class="dt">JSON</span> a <span class="kw">where</span>
    mimeUnrender _ <span class="fu">=</span> eitherDecodeLenient</code></pre></div>
<p><code>ReqBody</code>, <code>Get</code>, <code>Post</code> そして友達のために <code>JSON</code> を使うためのすべてのコードができました。 どのくらい理解が進んだかを確認するために <code>HTML</code> content-type に対応する実装をしてみましょう。 そして、そのウェブサービスのユーザが HTML データにアクセスできて、HTMLドキュメントをインクルード できる準備ができているかは、例えば <a href="https://api.jquery.com/load/">jQuery’s <code>load</code> function</a> を使ったり、リクエストヘッダに <code>Accept: text/html</code> を追加すれば確認できます。</p>
</section>
<section id="case-studies-servant-blaze-and-servant-lucid" class="level2">
<h2>Case-studies: <em>servant-blaze</em> and <em>servant-lucid</em></h2>
<p>Haskell から直接 HTML UI を書くには、最近では <a href="http://hackage.haskell.org/package/blaze-html">blaze-html</a> や <a href="http://hackage.haskell.org/package/lucid">lucid</a> が使われています。 <em>servant</em> ではどちらもサポートされています。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">HTMLLucid</span></code></pre></div>
<p>改めて書きますが、データ型は関数を変換する記法です。<em>blaze-html</em> と <em>lucid</em> は HTML から データを抽出する方法を提供しないので、今回はエンコードについて心配しないことにします。</p>
<p>両方のパッケージともに同じく <code>HTMLLucid</code> 型の <code>Accept</code> インスタンスを持ちます。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Accept</span> <span class="dt">HTMLLucid</span> <span class="kw">where</span>
    contentType _ <span class="fu">=</span> <span class="st">&quot;text&quot;</span> <span class="fu">//</span> <span class="st">&quot;html&quot;</span> <span class="fu">/:</span> (<span class="st">&quot;charset&quot;</span>, <span class="st">&quot;utf-8&quot;</span>)</code></pre></div>
<p>注目すべきは、このインスタンスは <em>http-media</em> にある <code>(/:)</code> 演算子を使っていることです。 この演算子は、上記の charset のような content-type についての追加情報を示します。</p>
<p>両方のパッケージでレンダリングインスタンスは似たような関数を呼び出す。その関数は適切な インスタンスで型を“抽象的な”HTML表現に変え、<code>ByteString</code>で書き出す。</p>
<p><em>lucid</em> の場合:</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">ToHtml</span> a <span class="ot">=&gt;</span> <span class="dt">MimeRender</span> <span class="dt">HTMLLucid</span> a <span class="kw">where</span>
    mimeRender _ <span class="fu">=</span> renderBS <span class="fu">.</span> toHtml

<span class="co">-- let's also provide an instance for lucid's</span>
<span class="co">-- 'Html' wrapper.</span>
<span class="kw">instance</span> <span class="dt">MimeRender</span> <span class="dt">HTMLLucid</span> (<span class="dt">Html</span> a) <span class="kw">where</span>
    mimeRender _ <span class="fu">=</span> renderBS</code></pre></div>
<p><em>blaze-html</em> の場合:</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- For this tutorial to compile 'HTMLLucid' and 'HTMLBlaze' have to be</span>
<span class="co">-- distinct. Usually you would stick to one html rendering library and then</span>
<span class="co">-- you can go with one 'HTML' type.</span>
<span class="kw">data</span> <span class="dt">HTMLBlaze</span>

<span class="kw">instance</span> <span class="dt">Accept</span> <span class="dt">HTMLBlaze</span> <span class="kw">where</span>
    contentType _ <span class="fu">=</span> <span class="st">&quot;text&quot;</span> <span class="fu">//</span> <span class="st">&quot;html&quot;</span> <span class="fu">/:</span> (<span class="st">&quot;charset&quot;</span>, <span class="st">&quot;utf-8&quot;</span>)

<span class="kw">instance</span> <span class="dt">ToMarkup</span> a <span class="ot">=&gt;</span> <span class="dt">MimeRender</span> <span class="dt">HTMLBlaze</span> a <span class="kw">where</span>
    mimeRender _ <span class="fu">=</span> renderHtml <span class="fu">.</span> Text.Blaze.Html.toHtml

<span class="co">-- while we're at it, just like for lucid we can</span>
<span class="co">-- provide an instance for rendering blaze's 'Html' type</span>
<span class="kw">instance</span> <span class="dt">MimeRender</span> <span class="dt">HTMLBlaze</span> <span class="dt">Text.Blaze.Html.Html</span> <span class="kw">where</span>
    mimeRender _ <span class="fu">=</span> renderHtml</code></pre></div>
<p>適切なクラス(<em>blaze-html</em> では <code>ToMarkup</code>、 <em>lucid</em> では <code>ToHtml</code>)のインスタンスを 用意できる限り、<a href="http://hackage.haskell.org/package/servant-blaze">servant-blaze</a> と <a href="http://hackage.haskell.org/package/servant-lucid">servant-lucid</a> の両方ともが content-type リストで <code>HTMLLucid</code> を使えます。</p>
<p><code>HTMLLucid</code> を表示するために <em>servant-lucid</em> を使うウェブサービスを書いてみましょう。 まずは import や pragma などを書きます。</p>
<p>次の API を用意します。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">PersonAPI</span> <span class="fu">=</span> <span class="st">&quot;persons&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON, HTMLLucid] [Person]</span></code></pre></div>
<p><code>Person</code> は以下のように定義します。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Person</span>
  {<span class="ot"> firstName ::</span> <span class="dt">String</span>
  ,<span class="ot"> lastName  ::</span> <span class="dt">String</span>
  } <span class="kw">deriving</span> <span class="dt">Generic</span> <span class="co">-- for the JSON instance</span>

<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Person</span></code></pre></div>
<p><em>lucid</em> に <code>Person</code> をテーブルの列として描画する方法を示しましょう。そして、<code>Person</code> のリストは person ごとの列として扱います。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- HTML serialization of a single person</span>
<span class="kw">instance</span> <span class="dt">ToHtml</span> <span class="dt">Person</span> <span class="kw">where</span>
  toHtml person <span class="fu">=</span>
    tr_ <span class="fu">$</span> <span class="kw">do</span>
      td_ (toHtml <span class="fu">$</span> firstName person)
      td_ (toHtml <span class="fu">$</span> lastName person)

  <span class="co">-- do not worry too much about this</span>
  toHtmlRaw <span class="fu">=</span> toHtml

<span class="co">-- HTML serialization of a list of persons</span>
<span class="kw">instance</span> <span class="dt">ToHtml</span> [<span class="dt">Person</span>] <span class="kw">where</span>
  toHtml persons <span class="fu">=</span> table_ <span class="fu">$</span> <span class="kw">do</span>
    tr_ <span class="fu">$</span> <span class="kw">do</span>
      th_ <span class="st">&quot;first name&quot;</span>
      th_ <span class="st">&quot;last name&quot;</span>

    <span class="co">-- this just calls toHtml on each person of the list</span>
    <span class="co">-- and concatenates the resulting pieces of HTML together</span>
    foldMap toHtml persons

  toHtmlRaw <span class="fu">=</span> toHtml</code></pre></div>
<p><code>Person</code> の値を作り、その一覧をサーバで扱いましょう。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">persons ::</span> [<span class="dt">Person</span>]
persons <span class="fu">=</span>
  [ <span class="dt">Person</span> <span class="st">&quot;Isaac&quot;</span>  <span class="st">&quot;Newton&quot;</span>
  , <span class="dt">Person</span> <span class="st">&quot;Albert&quot;</span> <span class="st">&quot;Einstein&quot;</span>
  ]

<span class="ot">personAPI ::</span> <span class="dt">Proxy</span> <span class="dt">PersonAPI</span>
personAPI <span class="fu">=</span> <span class="dt">Proxy</span>

<span class="ot">server4 ::</span> <span class="dt">Server</span> <span class="dt">PersonAPI</span>
server4 <span class="fu">=</span> return persons

<span class="ot">app2 ::</span> <span class="dt">Application</span>
app2 <span class="fu">=</span> serve personAPI server4</code></pre></div>
<p>これで大丈夫です。 この例題は <code>dist/build/tutorial/tutorial 4</code> で実行できます。</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"> $ <span class="kw">curl</span> http://localhost:8081/persons
 [<span class="dt">{&quot;lastName&quot;:&quot;Newton&quot;,&quot;firstName&quot;:&quot;Isaac&quot;},{&quot;lastName&quot;:&quot;Einstein&quot;,&quot;firstName&quot;:&quot;Albert&quot;}</span>]
 $ <span class="kw">curl</span> -H <span class="st">'Accept: text/html'</span> http://localhost:8081/persons
 <span class="kw">&lt;table&gt;&lt;</span>tr<span class="kw">&gt;&lt;</span>td<span class="kw">&gt;</span>first name<span class="kw">&lt;</span>/td<span class="kw">&gt;&lt;</span>td<span class="kw">&gt;</span>last name<span class="kw">&lt;</span>/td<span class="kw">&gt;&lt;</span>/tr<span class="kw">&gt;&lt;</span>tr<span class="kw">&gt;&lt;</span>td<span class="kw">&gt;</span>Isaac<span class="kw">&lt;</span>/td<span class="kw">&gt;&lt;</span>td<span class="kw">&gt;</span>Newton<span class="kw">&lt;</span>/td<span class="kw">&gt;&lt;</span>/tr<span class="kw">&gt;&lt;</span>tr<span class="kw">&gt;&lt;</span>td<span class="kw">&gt;</span>Albert<span class="kw">&lt;</span>/td<span class="kw">&gt;&lt;</span>td<span class="kw">&gt;</span>Einstein<span class="kw">&lt;</span>/td<span class="kw">&gt;&lt;</span>/tr<span class="kw">&gt;&lt;</span>/table<span class="kw">&gt;</span>
 <span class="co"># or just point your browser to http://localhost:8081/persons</span></code></pre></div>
</section>
</section>
<section id="the-eithert-servanterr-io-monad" class="level1">
<h1>The <code>EitherT ServantErr IO</code> monad</h1>
<p>ハンドラの中心には <code>EitherT ServantErr IO</code> モナドがあります。1つ不思議な事は、どうしてこのモナド なのでしょうか？ 答えは、以下の性質を持つ最も単純なモナドだから、です。</p>
<ul>
<li>成功した場合の結果または失敗した場合のエラーを返します。</li>
<li>IO を取り扱えます。多くのウェブサービスは <code>IO</code> で扱うデータベースのインターフェースとして存在します。</li>
</ul>
<p>定義を思い出してみましょう。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- from the Prelude</span>
<span class="kw">data</span> <span class="dt">Either</span> e a <span class="fu">=</span> <span class="dt">Left</span> e <span class="fu">|</span> <span class="dt">Right</span> a

<span class="co">-- from the 'either' package at</span>
<span class="co">-- http://hackage.haskell.org/package/either-4.3.3.2/docs/Control-Monad-Trans-Either.html</span>
<span class="kw">newtype</span> <span class="dt">EitherT</span> e m a
  <span class="fu">=</span> <span class="dt">EitherT</span> {<span class="ot"> runEitherT ::</span> m (<span class="dt">Either</span> e a) }</code></pre></div>
<p>要するに、<code>EitherT ServantErr IO a</code> 型のハンドラは <code>IO (Either ServantErr a)</code> 型を操作したもの と単に等価であることを意味しています。これはつまりエラーか結果を返す IO アクションです。</p>
<p>前述の <code>either</code> パッケージは見る価値があります。以下も大事なことです。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">left ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> <span class="dt">EitherT</span> e m a</code></pre></div>
<p>これを使うとハンドラからエラーを返せます。</p>
<p>ハンドラで処理しようとしていることの多くは IO を動かすことで、その結果によってエラーを返したり、 処理を中断したりしたいと思うかもしれません。次の2つの章ではこの方法を示します。</p>
<section id="performing-io" class="level2">
<h2>Performing IO</h2>
<p>上述のうちのもう1つの大事なインスタンスは、<code>MonadIO m =&gt; MonadIO (EitherT e m)</code> です。 <a href="http://hackage.haskell.org/package/transformers-0.4.3.0/docs/Control-Monad-IO-Class.html"><code>MonadIO</code></a> は、<em>transformers</em> パッケージにあるクラスで、以下のように定義されています。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">MonadIO</span> m <span class="kw">where</span>
<span class="ot">  liftIO ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> m a</code></pre></div>
<p>明らかに、IO モナドは <code>MonadIO</code> インスタンスを提供しています。 したがって、任意の <code>e</code> 型において、<code>EitherT e IO</code> は <code>MonadIO</code> を持っています。 ハンドラ内で IO 操作する任意の kind を実行したければ、<code>liftIO</code> を使いましょう。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">IOAPI1</span> <span class="fu">=</span> <span class="st">&quot;myfile.txt&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] FileContent</span>

<span class="kw">newtype</span> <span class="dt">FileContent</span> <span class="fu">=</span> <span class="dt">FileContent</span>
  {<span class="ot"> content ::</span> <span class="dt">String</span> }
  <span class="kw">deriving</span> <span class="dt">Generic</span>

<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">FileContent</span>

<span class="ot">server5 ::</span> <span class="dt">Server</span> <span class="dt">IOAPI1</span>
server5 <span class="fu">=</span> <span class="kw">do</span>
  filecontent <span class="ot">&lt;-</span> liftIO (readFile <span class="st">&quot;myfile.txt&quot;</span>)
  return (<span class="dt">FileContent</span> filecontent)</code></pre></div>
</section>
<section id="failing-through-servanterr" class="level2">
<h2>Failing, through <code>ServantErr</code></h2>
<p>もし適切なHTTPステータスコードとエラーメッセージを使ってエンドポイントで決められた結果を 明示的に失敗させたいのであれば、上述の <code>left</code> 関数を使うか、<code>ServantErr</code> 型の適切な値を 生成しましょう。ServantErr は以下のように定義されています。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ServantErr</span> <span class="fu">=</span> <span class="dt">ServantErr</span>
    {<span class="ot"> errHTTPCode     ::</span> <span class="dt">Int</span>
    ,<span class="ot"> errReasonPhrase ::</span> <span class="dt">String</span>
    ,<span class="ot"> errBody         ::</span> <span class="dt">ByteString</span> <span class="co">-- lazy bytestring</span>
    ,<span class="ot"> errHeaders      ::</span> [<span class="dt">Header</span>]
    }</code></pre></div>
<p>多くの標準的な値は、<code>Servant.Server</code> モジュールで提供されています。もしこれらの値を使うけど 一部を変更したい場合には、以下の record update syntax を使いましょう。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">failingHandler ::</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> ()
failingHandler <span class="fu">=</span> left myerr

  <span class="kw">where</span><span class="ot"> myerr ::</span> <span class="dt">ServantErr</span>
        myerr <span class="fu">=</span> err503 { errBody <span class="fu">=</span> <span class="st">&quot;Sorry dear user.&quot;</span> }</code></pre></div>
<p>以下の例は、“myfile.txt” が存在しなかった場合にレスポンスボディに含まれるカスタマイズされた 404-Not-Found エラーメッセージです。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">server6 ::</span> <span class="dt">Server</span> <span class="dt">IOAPI1</span>
server6 <span class="fu">=</span> <span class="kw">do</span>
  exists <span class="ot">&lt;-</span> liftIO (doesFileExist <span class="st">&quot;myfile.txt&quot;</span>)
  <span class="kw">if</span> exists
    <span class="kw">then</span> liftIO (readFile <span class="st">&quot;myfile.txt&quot;</span>) <span class="fu">&gt;&gt;=</span> return <span class="fu">.</span> <span class="dt">FileContent</span>
    <span class="kw">else</span> left custom404Err

  <span class="kw">where</span> custom404Err <span class="fu">=</span> err404 { errBody <span class="fu">=</span> <span class="st">&quot;myfile.txt just isn't there, please leave this server alone.&quot;</span> }</code></pre></div>
<p><code>dist/build/tutorial/tutorial 5</code> でこのサーバを動かせます。 初めはファイルが存在しない状態でクエリを送ってみましょう。</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"> $ <span class="kw">curl</span> --verbose http://localhost:8081/myfile.txt
 [<span class="kw">snip</span>]
 <span class="kw">*</span> Connected to localhost (127.0.0.1) <span class="kw">port</span> 8081 (#0)
 <span class="kw">&gt;</span> <span class="kw">GET</span> /myfile.txt HTTP/1.1
 <span class="kw">&gt;</span> <span class="kw">User-Agent</span>: curl/7.30.0
 <span class="kw">&gt;</span> <span class="kw">Host</span>: localhost:8081
 <span class="kw">&gt;</span> <span class="kw">Accept</span>: */*
 <span class="kw">&gt;</span>
 <span class="kw">&lt;</span> <span class="kw">HTTP/1.1</span> 404 Not Found
 [<span class="kw">snip</span>]
 <span class="kw">myfile.txt</span> just isnt there, please leave this server alone.

 $ <span class="kw">echo</span> Hello <span class="kw">&gt;</span> myfile.txt

 $ <span class="kw">curl</span> --verbose http://localhost:8081/myfile.txt
 [<span class="kw">snip</span>]
 <span class="kw">*</span> Connected to localhost (127.0.0.1) <span class="kw">port</span> 8081 (#0)
 <span class="kw">&gt;</span> <span class="kw">GET</span> /myfile.txt HTTP/1.1
 <span class="kw">&gt;</span> <span class="kw">User-Agent</span>: curl/7.30.0
 <span class="kw">&gt;</span> <span class="kw">Host</span>: localhost:8081
 <span class="kw">&gt;</span> <span class="kw">Accept</span>: */*
 <span class="kw">&gt;</span>
 <span class="kw">&lt;</span> <span class="kw">HTTP/1.1</span> 200 OK
 [<span class="kw">snip</span>]
 <span class="kw">&lt;</span> <span class="kw">Content-Type</span>: application/json
 [<span class="kw">snip</span>]
 <span class="dt">{&quot;content&quot;:&quot;Hello\n&quot;}</span></code></pre></div>
</section>
</section>
<section id="response-headers" class="level1">
<h1>Response headers</h1>
<p>レスポンスにヘッダを加えるためには <a href="http://hackage.haskell.org/package/servant-0.4.4/docs/Servant-API-ResponseHeaders.html">addHeader</a> を使います。以下の例のように API の型が変わることに注意しましょう。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">MyHandler</span> <span class="fu">=</span> <span class="dt">Get</span> <span class="ch">'[JSON] (Headers '</span>[<span class="dt">Header</span> <span class="st">&quot;X-An-Int&quot;</span> <span class="dt">Int</span>] <span class="dt">User</span>)

<span class="ot">myHandler ::</span> <span class="dt">Server</span> <span class="dt">MyHandler</span>
myHandler <span class="fu">=</span> return <span class="fu">$</span> addHeader <span class="dv">1797</span> albert</code></pre></div>
</section>
<section id="serving-static-files" class="level1">
<h1>Serving static files</h1>
<p><em>servant-server</em> は Web API 内でのあるパス以下のディレクトリのコンテンツをサーブする方法も提供します。 <code>Raw</code> 結合子は任意の WAI アプリケーションをつなぐ API で使われます。servant-server は WAI アプリを サーブするのにファイルやディレクトリを取得する機能を提供すます。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- exported by Servant and Servant.Server</span>
<span class="ot">serveDirectory ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">Server</span> <span class="dt">Raw</span></code></pre></div>
<p><code>serveDirectory</code> の引数は有効なディレクトリへのパスでなければなりません。 以下に例を示します。これは <code>dist/build/tutorial/tutorial 6</code> でこのサーバを動かせます。 (必ず <em>servant-examples/</em> ディレクトリで動かさなければなりません) このチュートリアルで網羅されている大量のコードを動かすウェブサーバです。</p>
<p>API の定義は次のようになります。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">CodeAPI</span> <span class="fu">=</span> <span class="st">&quot;code&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Raw</span></code></pre></div>
<p>サーバ</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">codeAPI ::</span> <span class="dt">Proxy</span> <span class="dt">CodeAPI</span>
codeAPI <span class="fu">=</span> <span class="dt">Proxy</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">server7 ::</span> <span class="dt">Server</span> <span class="dt">CodeAPI</span>
server7 <span class="fu">=</span> serveDirectory <span class="st">&quot;tutorial&quot;</span>

<span class="ot">app3 ::</span> <span class="dt">Application</span>
app3 <span class="fu">=</span> serve codeAPI server7</code></pre></div>
<p>このサーバは <code>/code</code> でパスが始まる任意のリクエストにマッチします。 そしてこのプログラムを動かしているパスの <em>tutorial/</em> ディレクトリの中で、 残りのリクエストパスで指定されるパスでファイルを探します。</p>
<p>これは以下のようにも言えます。</p>
<ul>
<li>もしクライアントが <code>/code/foo.txt</code> をリクエストした場合、サーバは <code>./tutorial/foo.txt</code> を探します。(これは失敗します。)</li>
<li>もしクライアントが <code>/code/T1.hs</code> をリクエストした場合、サーバは <code>./tutorial/T1.hs</code> を探します。(これは成功します。)</li>
<li>もしクライアントが <code>/code/foo/bar/baz/movie.mp4</code> をリクエストした場合、サーバは <code>./tutorial/foo/bar/baz/movie.mp4</code> を探します。(これは失敗します。)</li>
</ul>
<p>これが実際に動くサーバです。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">$</span> curl http<span class="fu">://</span>localhost<span class="fu">:</span><span class="dv">8081</span><span class="fu">/</span>code<span class="fu">/</span>T1.hs
<span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE TypeFamilies #-}</span>
<span class="ot">{-# LANGUAGE DeriveGeneric #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="kw">module</span> <span class="dt">T1</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.Aeson</span>
<span class="kw">import </span><span class="dt">Data.Time.Calendar</span>
<span class="kw">import </span><span class="dt">GHC.Generics</span>
<span class="kw">import </span><span class="dt">Network.Wai</span>
<span class="kw">import </span><span class="dt">Servant</span>

<span class="kw">data</span> <span class="dt">User</span> <span class="fu">=</span> <span class="dt">User</span>
  {<span class="ot"> name ::</span> <span class="dt">String</span>
  ,<span class="ot"> age ::</span> <span class="dt">Int</span>
  ,<span class="ot"> email ::</span> <span class="dt">String</span>
  ,<span class="ot"> registration_date ::</span> <span class="dt">Day</span>
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Generic</span>)

<span class="co">-- orphan ToJSON instance for Day. necessary to derive one for User</span>
<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Day</span> <span class="kw">where</span>
  <span class="co">-- display a day in YYYY-mm-dd format</span>
  toJSON d <span class="fu">=</span> toJSON (showGregorian d)

<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">User</span>

<span class="kw">type</span> <span class="dt">UserAPI</span> <span class="fu">=</span> <span class="st">&quot;users&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] [User]</span>

<span class="ot">users ::</span> [<span class="dt">User</span>]
users <span class="fu">=</span>
  [ <span class="dt">User</span> <span class="st">&quot;Isaac Newton&quot;</span>    <span class="dv">372</span> <span class="st">&quot;isaac@newton.co.uk&quot;</span> (fromGregorian <span class="dv">1683</span>  <span class="dv">3</span> <span class="dv">1</span>)
  , <span class="dt">User</span> <span class="st">&quot;Albert Einstein&quot;</span> <span class="dv">136</span> <span class="st">&quot;ae@mc2.org&quot;</span>         (fromGregorian <span class="dv">1905</span> <span class="dv">12</span> <span class="dv">1</span>)
  ]

<span class="ot">userAPI ::</span> <span class="dt">Proxy</span> <span class="dt">UserAPI</span>
userAPI <span class="fu">=</span> <span class="dt">Proxy</span>

<span class="ot">server ::</span> <span class="dt">Server</span> <span class="dt">UserAPI</span>
server <span class="fu">=</span> return users

<span class="ot">app ::</span> <span class="dt">Application</span>
app <span class="fu">=</span> serve userAPI server
<span class="fu">$</span> curl http<span class="fu">://</span>localhost<span class="fu">:</span><span class="dv">8081</span><span class="fu">/</span>code<span class="fu">/</span>tutorial<span class="fu">.</span>hs
<span class="kw">import </span><span class="dt">Network.Wai</span>
<span class="kw">import </span><span class="dt">Network.Wai.Handler.Warp</span>
<span class="kw">import </span><span class="dt">System.Environment</span>

<span class="kw">import qualified</span> <span class="dt">T1</span>
<span class="kw">import qualified</span> <span class="dt">T2</span>
<span class="kw">import qualified</span> <span class="dt">T3</span>
<span class="kw">import qualified</span> <span class="dt">T4</span>
<span class="kw">import qualified</span> <span class="dt">T5</span>
<span class="kw">import qualified</span> <span class="dt">T6</span>
<span class="kw">import qualified</span> <span class="dt">T7</span>
<span class="kw">import qualified</span> <span class="dt">T9</span>
<span class="kw">import qualified</span> <span class="dt">T10</span>

<span class="ot">app ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> (<span class="dt">Application</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
app n f <span class="fu">=</span> <span class="kw">case</span> n <span class="kw">of</span>
  <span class="st">&quot;1&quot;</span> <span class="ot">-&gt;</span> f T1.app
  <span class="st">&quot;2&quot;</span> <span class="ot">-&gt;</span> f T2.app
  <span class="st">&quot;3&quot;</span> <span class="ot">-&gt;</span> f T3.app
  <span class="st">&quot;4&quot;</span> <span class="ot">-&gt;</span> f T4.app
  <span class="st">&quot;5&quot;</span> <span class="ot">-&gt;</span> f T5.app
  <span class="st">&quot;6&quot;</span> <span class="ot">-&gt;</span> f T6.app
  <span class="st">&quot;7&quot;</span> <span class="ot">-&gt;</span> f T7.app
  <span class="st">&quot;8&quot;</span> <span class="ot">-&gt;</span> f T3.app
  <span class="st">&quot;9&quot;</span> <span class="ot">-&gt;</span> T9.writeJSFiles <span class="fu">&gt;&gt;</span> f T9.app
  <span class="st">&quot;10&quot;</span> <span class="ot">-&gt;</span> f T10.app
  _   <span class="ot">-&gt;</span> usage

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> <span class="kw">do</span>
  args <span class="ot">&lt;-</span> getArgs
  <span class="kw">case</span> args <span class="kw">of</span>
    [n] <span class="ot">-&gt;</span> app n (run <span class="dv">8081</span>)
    _   <span class="ot">-&gt;</span> usage

<span class="ot">usage ::</span> <span class="dt">IO</span> ()
usage <span class="fu">=</span> <span class="kw">do</span>
  putStrLn <span class="st">&quot;Usage:\t tutorial N&quot;</span>
  putStrLn <span class="st">&quot;\t\twhere N is the number of the example you want to run.&quot;</span>

<span class="fu">$</span> curl http<span class="fu">://</span>localhost<span class="fu">:</span><span class="dv">8081</span><span class="fu">/</span>foo
not found</code></pre></div>
</section>
<section id="nested-apis" class="level1">
<h1>Nested APIs</h1>
<p>重複を避けて、組み立て式の方法でどうやってAPIを定義することができるか見てみましょう。 シンプルな例を考えます。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">UserAPI3</span> <span class="fu">=</span> <span class="co">-- view the user with given userid, in JSON</span>
                <span class="dt">Capture</span> <span class="st">&quot;userid&quot;</span> <span class="dt">Int</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] User</span>

           <span class="fu">:&lt;|&gt;</span> <span class="co">-- delete the user with given userid. empty response</span>
                <span class="dt">Capture</span> <span class="st">&quot;userid&quot;</span> <span class="dt">Int</span> <span class="fu">:&gt;</span> <span class="dt">Delete</span> <span class="ch">'[] ()</span></code></pre></div>
<p>むしろ <code>userid</code> をくくりだすことができます。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">UserAPI4</span> <span class="fu">=</span> <span class="dt">Capture</span> <span class="st">&quot;userid&quot;</span> <span class="dt">Int</span> <span class="fu">:&gt;</span>
  (    <span class="dt">Get</span> <span class="ch">'[JSON] User</span>
  <span class="fu">:&lt;|&gt;</span> <span class="dt">Delete</span> <span class="ch">'[] ()</span>
  )</code></pre></div>
<p>しかし、対応する <code>Server</code> の型に影響することには注意しなければなりません。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Server</span> <span class="dt">UserAPI3</span> <span class="fu">=</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> <span class="dt">User</span>)
             <span class="fu">:&lt;|&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> ())

<span class="dt">Server</span> <span class="dt">UserAPI4</span> <span class="fu">=</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (    <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> <span class="dt">User</span>
                         <span class="fu">:&lt;|&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> ()
                         )</code></pre></div>
<p>前者の場合には、ハンドラごとに <em>userid</em> 引数を取ります。 後者の場合には、<code>Server</code> 全体が <em>userid</em> を取り、引数無しで <code>EitherT</code> を処理するハンドラを持ちます。 以下のようにも書けます。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">server8 ::</span> <span class="dt">Server</span> <span class="dt">UserAPI3</span>
server8 <span class="fu">=</span> getUser <span class="fu">:&lt;|&gt;</span> deleteUser

  <span class="kw">where</span><span class="ot"> getUser ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> <span class="dt">User</span>
        getUser _userid <span class="fu">=</span> error <span class="st">&quot;...&quot;</span>

<span class="ot">        deleteUser ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> ()
        deleteUser _userid <span class="fu">=</span> error <span class="st">&quot;...&quot;</span>

<span class="co">-- notice how getUser and deleteUser</span>
<span class="co">-- have a different type! no argument anymore,</span>
<span class="co">-- the argument directly goes to the whole Server</span>
<span class="ot">server9 ::</span> <span class="dt">Server</span> <span class="dt">UserAPI4</span>
server9 userid <span class="fu">=</span> getUser userid <span class="fu">:&lt;|&gt;</span> deleteUser userid

  <span class="kw">where</span><span class="ot"> getUser ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> <span class="dt">User</span>
        getUser <span class="fu">=</span> error <span class="st">&quot;...&quot;</span>

<span class="ot">        deleteUser ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> ()
        deleteUser <span class="fu">=</span> error <span class="st">&quot;...&quot;</span></code></pre></div>
<p>くくりだせる <code>Capture</code> は何も特別でなく、任意の結合子に対して可能であることに注目しましょう。 くくりだせる結合子を使ったいくつかの API の例を示します。 これを使えば完全に有効に機能するサーバを書くことができます。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- we just factor out the &quot;users&quot; path fragment</span>
<span class="kw">type</span> <span class="dt">API1</span> <span class="fu">=</span> <span class="st">&quot;users&quot;</span> <span class="fu">:&gt;</span>
  (    <span class="dt">Get</span> <span class="ch">'[JSON] [User] -- user listing</span>
  <span class="fu">:&lt;|&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;userid&quot;</span> <span class="dt">Int</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] User -- view a particular user</span>
  )

<span class="co">-- we factor out the Request Body</span>
<span class="kw">type</span> <span class="dt">API2</span> <span class="fu">=</span> <span class="dt">ReqBody</span> <span class="ch">'[JSON] User :&gt;</span>
  (    <span class="dt">Get</span> <span class="ch">'[JSON] User -- just display the same user back, don'</span>t register it
  <span class="fu">:&lt;|&gt;</span> <span class="dt">Post</span> <span class="ch">'[JSON] ()  -- register the user. empty response</span>
  )

<span class="co">-- we factor out a Header</span>
<span class="kw">type</span> <span class="dt">API3</span> <span class="fu">=</span> <span class="dt">Header</span> <span class="st">&quot;Authorization&quot;</span> <span class="dt">Token</span> <span class="fu">:&gt;</span>
  (    <span class="dt">Get</span> <span class="ch">'[JSON] SecretData -- get some secret data, if authorized</span>
  <span class="fu">:&lt;|&gt;</span> <span class="dt">ReqBody</span> <span class="ch">'[JSON] SecretData :&gt; Post '</span>[] () <span class="co">-- add some secret data, if authorized</span>
  )

<span class="kw">newtype</span> <span class="dt">Token</span> <span class="fu">=</span> <span class="dt">Token</span> <span class="dt">ByteString</span>
<span class="kw">newtype</span> <span class="dt">SecretData</span> <span class="fu">=</span> <span class="dt">SecretData</span> <span class="dt">ByteString</span></code></pre></div>
<p>このアプローチでモジュール構造のAPIを定義できます。 最終的に巨大な API type として組み立てることができます。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">UsersAPI</span> <span class="fu">=</span>
       <span class="dt">Get</span> <span class="ch">'[JSON] [User] -- list users</span>
  <span class="fu">:&lt;|&gt;</span> <span class="dt">ReqBody</span> <span class="ch">'[JSON] User :&gt; Post '</span>[] () <span class="co">-- add a user</span>
  <span class="fu">:&lt;|&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;userid&quot;</span> <span class="dt">Int</span> <span class="fu">:&gt;</span>
         ( <span class="dt">Get</span> <span class="ch">'[JSON] User -- view a user</span>
      <span class="fu">:&lt;|&gt;</span> <span class="dt">ReqBody</span> <span class="ch">'[JSON] User :&gt; Put '</span>[] () <span class="co">-- update a user</span>
      <span class="fu">:&lt;|&gt;</span> <span class="dt">Delete</span> <span class="ch">'[] () -- delete a user</span>
         )

<span class="ot">usersServer ::</span> <span class="dt">Server</span> <span class="dt">UsersAPI</span>
usersServer <span class="fu">=</span> getUsers <span class="fu">:&lt;|&gt;</span> newUser <span class="fu">:&lt;|&gt;</span> userOperations

  <span class="kw">where</span><span class="ot"> getUsers ::</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> [<span class="dt">User</span>]
        getUsers <span class="fu">=</span> error <span class="st">&quot;...&quot;</span>

<span class="ot">        newUser ::</span> <span class="dt">User</span> <span class="ot">-&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> ()
        newUser <span class="fu">=</span> error <span class="st">&quot;...&quot;</span>

        userOperations userid <span class="fu">=</span>
          viewUser userid <span class="fu">:&lt;|&gt;</span> updateUser userid <span class="fu">:&lt;|&gt;</span> deleteUser userid

          <span class="kw">where</span>
<span class="ot">            viewUser ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> <span class="dt">User</span>
            viewUser <span class="fu">=</span> error <span class="st">&quot;...&quot;</span>

<span class="ot">            updateUser ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">User</span> <span class="ot">-&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> ()
            updateUser <span class="fu">=</span> error <span class="st">&quot;...&quot;</span>

<span class="ot">            deleteUser ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> ()
            deleteUser <span class="fu">=</span> error <span class="st">&quot;...&quot;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">ProductsAPI</span> <span class="fu">=</span>
       <span class="dt">Get</span> <span class="ch">'[JSON] [Product] -- list products</span>
  <span class="fu">:&lt;|&gt;</span> <span class="dt">ReqBody</span> <span class="ch">'[JSON] Product :&gt; Post '</span>[] () <span class="co">-- add a product</span>
  <span class="fu">:&lt;|&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;productid&quot;</span> <span class="dt">Int</span> <span class="fu">:&gt;</span>
         ( <span class="dt">Get</span> <span class="ch">'[JSON] Product -- view a product</span>
      <span class="fu">:&lt;|&gt;</span> <span class="dt">ReqBody</span> <span class="ch">'[JSON] Product :&gt; Put '</span>[] () <span class="co">-- update a product</span>
      <span class="fu">:&lt;|&gt;</span> <span class="dt">Delete</span> <span class="ch">'[] () -- delete a product</span>
         )

<span class="kw">data</span> <span class="dt">Product</span> <span class="fu">=</span> <span class="dt">Product</span> {<span class="ot"> productId ::</span> <span class="dt">Int</span> }

<span class="ot">productsServer ::</span> <span class="dt">Server</span> <span class="dt">ProductsAPI</span>
productsServer <span class="fu">=</span> getProducts <span class="fu">:&lt;|&gt;</span> newProduct <span class="fu">:&lt;|&gt;</span> productOperations

  <span class="kw">where</span><span class="ot"> getProducts ::</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> [<span class="dt">Product</span>]
        getProducts <span class="fu">=</span> error <span class="st">&quot;...&quot;</span>

<span class="ot">        newProduct ::</span> <span class="dt">Product</span> <span class="ot">-&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> ()
        newProduct <span class="fu">=</span> error <span class="st">&quot;...&quot;</span>

        productOperations productid <span class="fu">=</span>
          viewProduct productid <span class="fu">:&lt;|&gt;</span> updateProduct productid <span class="fu">:&lt;|&gt;</span> deleteProduct productid

          <span class="kw">where</span>
<span class="ot">            viewProduct ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> <span class="dt">Product</span>
            viewProduct <span class="fu">=</span> error <span class="st">&quot;...&quot;</span>

<span class="ot">            updateProduct ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Product</span> <span class="ot">-&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> ()
            updateProduct <span class="fu">=</span> error <span class="st">&quot;...&quot;</span>

<span class="ot">            deleteProduct ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> ()
            deleteProduct <span class="fu">=</span> error <span class="st">&quot;...&quot;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">CombinedAPI</span> <span class="fu">=</span> <span class="st">&quot;users&quot;</span> <span class="fu">:&gt;</span> <span class="dt">UsersAPI</span>
              <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;products&quot;</span> <span class="fu">:&gt;</span> <span class="dt">ProductsAPI</span>

<span class="ot">server10 ::</span> <span class="dt">Server</span> <span class="dt">CombinedAPI</span>
server10 <span class="fu">=</span> usersServer <span class="fu">:&lt;|&gt;</span> productsServer</code></pre></div>
<p>最後に、user と product API がほとんど同じなので、1つにまとめることができます。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="co">-- API for values of type 'a'</span>
<span class="co">-- indexed by values of type 'i'</span>
<span class="kw">type</span> <span class="dt">APIFor</span> a i <span class="fu">=</span>
       <span class="dt">Get</span> <span class="ch">'[JSON] [a] -- list '</span>a's
  <span class="fu">:&lt;|&gt;</span> <span class="dt">ReqBody</span> <span class="ch">'[JSON] a :&gt; Post '</span>[] () <span class="co">-- add an 'a'</span>
  <span class="fu">:&lt;|&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;id&quot;</span> i <span class="fu">:&gt;</span>
         ( <span class="dt">Get</span> <span class="ch">'[JSON] a -- view an '</span>a' given its <span class="st">&quot;identifier&quot;</span> <span class="kw">of</span> <span class="kw">type</span> <span class="ch">'i'</span>
      <span class="fu">:&lt;|&gt;</span> <span class="dt">ReqBody</span> <span class="ch">'[JSON] a :&gt; Put '</span>[] () <span class="co">-- update an 'a'</span>
      <span class="fu">:&lt;|&gt;</span> <span class="dt">Delete</span> <span class="ch">'[] () -- delete an '</span>a'
         )

<span class="co">-- Build the appropriate 'Server'</span>
<span class="co">-- given the handlers of the right type.</span>
<span class="ot">serverFor ::</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> [a] <span class="co">-- handler for listing of 'a's</span>
          <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> ()) <span class="co">-- handler for adding an 'a'</span>
          <span class="ot">-&gt;</span> (i <span class="ot">-&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> a) <span class="co">-- handler for viewing an 'a' given its identifier of type 'i'</span>
          <span class="ot">-&gt;</span> (i <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> ()) <span class="co">-- updating an 'a' with given id</span>
          <span class="ot">-&gt;</span> (i <span class="ot">-&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> ()) <span class="co">-- deleting an 'a' given its id</span>
          <span class="ot">-&gt;</span> <span class="dt">Server</span> (<span class="dt">APIFor</span> a i)
serverFor <span class="fu">=</span> error <span class="st">&quot;...&quot;</span>
<span class="co">-- implementation left as an exercise. contact us on IRC</span>
<span class="co">-- or the mailing list if you get stuck!</span></code></pre></div>
</section>
<section id="using-another-monad-for-your-handlers" class="level1">
<h1>Using another monad for your handlers</h1>
<p><code>Server</code> が HTTP メソッドの結合子をどのように <code>EitherT ServantErr IO</code> に変えたのかを思い出してみましょう。 <code>Server</code> は実際には単純な type synonym に過ぎません。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Server</span> api <span class="fu">=</span> <span class="dt">ServerT</span> api (<span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span>)</code></pre></div>
<p><code>ServerT</code> は <code>HasServer</code> クラスの一部のハンドラが必要な型を算出する type family です。これは3番目のパラメータ を取ることを除けば <code>Server</code> のようなものです。このパラメータはハンドラを差し込みたいモナドもしくはハンドラが返す型 です。3番目のパラメータはエンドポイントのハンドラが返す型を特定するのに使います。 <code>ServerT (Get '[JSON] Person) SomeMonad</code> を処理すると、<code>SomeMonad Person</code> を返します。</p>
<p>最初の、そして主な疑問はどうしてこれが必要なのでしょうか。他のモナドに差し込むハンドラをどのように書けばいいのでしょうか。</p>
<section id="natural-transformations" class="level2">
<h2>Natural transformations</h2>
<p>もし任意の <code>a</code> において <code>m a</code> から <code>n a</code> へ変換できる関数があったとすると、その関数はどういうもの になるのでしょうか。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> m <span class="fu">:~&gt;</span> n <span class="fu">=</span> <span class="dt">Nat</span> {<span class="ot"> unNat ::</span> forall a<span class="fu">.</span> m a <span class="ot">-&gt;</span> n a}

<span class="co">-- For example</span>
<span class="co">-- listToMaybeNat ::`[] :~&gt; Maybe`</span>
<span class="co">-- listToMaybeNat = Nat listToMaybe  -- from Data.Maybe</span></code></pre></div>
<p>(<code>Nat</code> は “natural transformation” のことで、今回取り扱うものです。)</p>
<p>もし <code>EitherT ServantErr IO</code> とは別のモナド(<code>Reader String</code> モナド)または型を使ってハンドラを 書きたいのであれば、最初に用意すべきなのは以下の関数です。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">readerToEither ::</span> <span class="dt">Reader</span> <span class="dt">String</span> <span class="fu">:~&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span></code></pre></div>
<p><code>readerToEither'</code> から始めましょう。例えば “hi” のような <code>String</code> をそれに供給する処理を <code>Reader</code> にさせなければならないことは明らかです。<code>a</code> を取り出して <code>EitherT</code> の中で <code>return</code> しましょう。変わった型を持たせるために <code>Nat</code> コンストラクタを使った関数でラップします。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">readerToEither' ::</span> forall a<span class="fu">.</span> <span class="dt">Reader</span> <span class="dt">String</span> a <span class="ot">-&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span> a
readerToEither' r <span class="fu">=</span> return (runReader r <span class="st">&quot;hi&quot;</span>)

<span class="ot">readerToEither ::</span> <span class="dt">Reader</span> <span class="dt">String</span> <span class="fu">:~&gt;</span> <span class="dt">EitherT</span> <span class="dt">ServantErr</span> <span class="dt">IO</span>
readerToEither <span class="fu">=</span> <span class="dt">Nat</span> readerToEither'</code></pre></div>
<p><code>Reader String</code> を差し込みハンドラを使って単純なウェブサービスを書いてみましょう。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">ReaderAPI</span> <span class="fu">=</span> <span class="st">&quot;a&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] Int</span>
            <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;b&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] String</span>

<span class="ot">readerAPI ::</span> <span class="dt">Proxy</span> <span class="dt">ReaderAPI</span>
readerAPI <span class="fu">=</span> <span class="dt">Proxy</span>

<span class="ot">readerServerT ::</span> <span class="dt">ServerT</span> <span class="dt">ReaderAPI</span> (<span class="dt">Reader</span> <span class="dt">String</span>)
readerServerT <span class="fu">=</span> a <span class="fu">:&lt;|&gt;</span> b

  <span class="kw">where</span><span class="ot"> a ::</span> <span class="dt">Reader</span> <span class="dt">String</span> <span class="dt">Int</span>
        a <span class="fu">=</span> return <span class="dv">1797</span>

<span class="ot">        b ::</span> <span class="dt">Reader</span> <span class="dt">String</span> <span class="dt">String</span>
        b <span class="fu">=</span> ask</code></pre></div>
<p>運の悪いことに <code>serve</code> の引数として <code>readerServerT</code> を使うことはできません。<code>serve</code> の 引数として使えるのは <code>Server ReaderAPI</code> です。これは <code>EitherT ServantErr IO</code> を差し込む ハンドラで使います。それでも上記は単純な解決方法の1つです。</p>
</section>
<section id="enter-enter" class="level2">
<h2>Enter <code>enter</code></h2>
<p>上で書いてきた <code>readerToEither</code> ですが、<code>serve</code> の正しい型を持つハンドラを作るために すべてのハンドラの戻り値にこれを正確に適用する必要があります。これを手動でやるのは面倒なので、 <code>enter</code> 関数が用意されています。これは <code>m</code> と <code>n</code> という2つのパラメータの型と <code>ServerT someapi m</code> の間の natural transformation を行い、<code>ServerT someapi n</code> を返します。</p>
<p>具体的には、ハンドラ上で <code>enter readerToEither</code> を使ってウェブサービスをラップします。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">readerServer ::</span> <span class="dt">Server</span> <span class="dt">ReaderAPI</span>
readerServer <span class="fu">=</span> enter readerToEither readerServerT

<span class="ot">app4 ::</span> <span class="dt">Application</span>
app4 <span class="fu">=</span> serve readerAPI readerServer</code></pre></div>
<p><code>dist/build/tutorial/tutorial 7</code> でこのウェブサービスを実行できます。</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">curl</span> http://localhost:8081/a
<span class="kw">1797</span>
$ <span class="kw">curl</span> http://localhost:8081/b
<span class="st">&quot;hi&quot;</span></code></pre></div>
</section>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p><em>servant</em> を使ってウェブサービス・ウェブアプリケーションを実装できるようになりました。 ここでは唯一、自分の結合子を組み込むのを取り扱いませんでしたが、このウェブサイトの別ページで扱っています。 残りの文章では <em>servant-client</em> と <em>servant-jquery</em>、 <em>servant-docs</em> について取り扱います。</p>
<div style="text-align: center;">
<p>
<a href="../../tutorial/api-type.html">Previous page: A web API as a type</a>
</p>
<p>
<a href="../../tutorial/client.html">Next page: Deriving Haskell functions to query an API</a>
</p>
</div>
</section>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
            -
            <a href="https://github.com/haskell-servant/haskell-servant.github.io">Source</a>
        </div>
    </body>
</html>
