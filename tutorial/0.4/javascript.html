<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Deriving Javascript functions to query an API - haskell-servant</title>
        <link rel="stylesheet" type="text/css" href="../../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../../">servant</a>
            </div>
            <div id="navigation">
                <a href="../../">Home</a>
                <a href="../../blog.html">Blog</a>
                <a href="../../tutorial">Tutorial</a>
                <a href="../../tips.html">Tips and tricks</a>
                <a href="../../talks.html">Talks</a>
                <a href="https://github.com/haskell-servant/servant">Github</a>
            </div>
        </div>

        <div id="content">
            <h1>Deriving Javascript functions to query an API</h1>

            
<p><em>servant</em> が API type を javascript の関数に変える方法を見てみましょう。その関数は ウェブサービスにクエリを送ることができます。導出されたコードは <em>jQuery</em> を使わせると仮定します が、純粋なjavascriptや他の<em>jQuery</em>ライブラリに基づくajaxリクエストを生成するコードを大変 簡単に適用することができます。</p>
<p>このために2つに分割されたシンプルなシンプルなページを考えます。一番上には検索ボックスがあり、 著者や題名でHaskell本の一覧、サイトに入った時間やキャラクタを削除する時間で更新 された結果の一覧から検索できます。一番下にはランダムな点をえるためのウェブサービスを使って 古典的な<a href="http://en.wikipedia.org/wiki/Approximations_of_%CF%80#Summing_a_circle.27s_area">probabilistic method to approximate pi</a> を見ることができます。最終的には2つのJavascriptファイルとともにHTMLファイルをサーブます。1つは API typeから自動的に生成され、もう1つはAPIにクエリを投げる関数ですぐに使える状態で提供されます。</p>
<p>この章のソースは literate haskell file として書かれています。 まずは言語拡張と import から始めましょう。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE DeriveGeneric #-}</span>
<span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>

<span class="kw">module</span> <span class="dt">Javascript</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Control.Monad.IO.Class</span>
<span class="kw">import </span><span class="dt">Data.Aeson</span>
<span class="kw">import </span><span class="dt">Data.Proxy</span>
<span class="kw">import </span><span class="dt">Data.Text</span> (<span class="dt">Text</span>)
<span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>
<span class="kw">import </span><span class="dt">GHC.Generics</span>
<span class="kw">import </span><span class="dt">Language.Javascript.JQuery</span>
<span class="kw">import </span><span class="dt">Network.Wai</span>
<span class="kw">import </span><span class="dt">Servant</span>
<span class="kw">import </span><span class="dt">Servant.JQuery</span>
<span class="kw">import </span><span class="dt">System.Random</span></code></pre></div>
<p>以下は API type と付随のデータタイプです。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">API</span> <span class="fu">=</span> <span class="st">&quot;point&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] Point</span>
      <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;books&quot;</span> <span class="fu">:&gt;</span> <span class="dt">QueryParam</span> <span class="st">&quot;q&quot;</span> <span class="dt">Text</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] (Search Book)</span>

<span class="kw">type</span> <span class="dt">API'</span> <span class="fu">=</span> <span class="dt">API</span> <span class="fu">:&lt;|&gt;</span> <span class="dt">Raw</span>

<span class="kw">data</span> <span class="dt">Point</span> <span class="fu">=</span> <span class="dt">Point</span>
  {<span class="ot"> x ::</span> <span class="dt">Double</span>
  ,<span class="ot"> y ::</span> <span class="dt">Double</span>
  } <span class="kw">deriving</span> <span class="dt">Generic</span>

<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Point</span>

<span class="kw">data</span> <span class="dt">Search</span> a <span class="fu">=</span> <span class="dt">Search</span>
  {<span class="ot"> query   ::</span> <span class="dt">Text</span>
  ,<span class="ot"> results ::</span> [a]
  } <span class="kw">deriving</span> <span class="dt">Generic</span>

<span class="ot">mkSearch ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Search</span> a
mkSearch <span class="fu">=</span> <span class="dt">Search</span>

<span class="kw">instance</span> <span class="dt">ToJSON</span> a <span class="ot">=&gt;</span> <span class="dt">ToJSON</span> (<span class="dt">Search</span> a)

<span class="kw">data</span> <span class="dt">Book</span> <span class="fu">=</span> <span class="dt">Book</span>
  {<span class="ot"> author ::</span> <span class="dt">Text</span>
  ,<span class="ot"> title  ::</span> <span class="dt">Text</span>
  ,<span class="ot"> year   ::</span> <span class="dt">Int</span>
  } <span class="kw">deriving</span> <span class="dt">Generic</span>

<span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Book</span>

<span class="ot">book ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Book</span>
book <span class="fu">=</span> <span class="dt">Book</span></code></pre></div>
<p>“書籍データベース” が必要です。 このガイドの目的は、データベースを以下の本に制限することです。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">books ::</span> [<span class="dt">Book</span>]
books <span class="fu">=</span>
  [ book <span class="st">&quot;Paul Hudak&quot;</span> <span class="st">&quot;The Haskell School of Expression: Learning Functional Programming through Multimedia&quot;</span> <span class="dv">2000</span>
  , book <span class="st">&quot;Bryan O'Sullivan, Don Stewart, and John Goerzen&quot;</span> <span class="st">&quot;Real World Haskell&quot;</span> <span class="dv">2008</span>
  , book <span class="st">&quot;Miran Lipovača&quot;</span> <span class="st">&quot;Learn You a Haskell for Great Good!&quot;</span> <span class="dv">2011</span>
  , book <span class="st">&quot;Graham Hutton&quot;</span> <span class="st">&quot;Programming in Haskell&quot;</span> <span class="dv">2007</span>
  , book <span class="st">&quot;Simon Marlow&quot;</span> <span class="st">&quot;Parallel and Concurrent Programming in Haskell&quot;</span> <span class="dv">2013</span>
  , book <span class="st">&quot;Richard Bird&quot;</span> <span class="st">&quot;Introduction to Functional Programming using Haskell&quot;</span> <span class="dv">1998</span>
  ]</code></pre></div>
<p>任意の検索文字 <code>q</code> を与えるとすると、本の一覧で大文字小文字を区別しない検索を実施しようとする。明らかに 最も適したアルゴリズムを試したり実装したりしているわけではありません。それはこのチュートリアルの対象外です。 もし一覧が小さければ、以下の単純な線形探索の例で十分です。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">searchBook ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Maybe</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> m (<span class="dt">Search</span> <span class="dt">Book</span>)
searchBook <span class="dt">Nothing</span>  <span class="fu">=</span> return (mkSearch <span class="st">&quot;&quot;</span> books)
searchBook (<span class="dt">Just</span> q) <span class="fu">=</span> return (mkSearch q books')

  <span class="kw">where</span> books' <span class="fu">=</span> filter (\b <span class="ot">-&gt;</span> q' <span class="ot">`T.isInfixOf`</span> T.toLower (author b)
                            <span class="fu">||</span> q' <span class="ot">`T.isInfixOf`</span> T.toLower (title b)
                        )
                        books
        q' <span class="fu">=</span> T.toLower q</code></pre></div>
<p><code>-1 &lt;= x,y &lt;= 1</code> の範囲の乱数 <code>(x, y)</code> を生成するエンドポイントも必要です。以下のコードには、 <code>System.Random</code> の <a href="http://hackage.haskell.org/package/random">random</a> を使っています。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">randomPoint ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> m <span class="dt">Point</span>
randomPoint <span class="fu">=</span> liftIO <span class="fu">.</span> getStdRandom <span class="fu">$</span> \g <span class="ot">-&gt;</span>
  <span class="kw">let</span> (rx, g')  <span class="fu">=</span> randomR (<span class="fu">-</span><span class="dv">1</span>, <span class="dv">1</span>) g
      (ry, g'') <span class="fu">=</span> randomR (<span class="fu">-</span><span class="dv">1</span>, <span class="dv">1</span>) g'
  <span class="kw">in</span> (<span class="dt">Point</span> rx ry, g'')</code></pre></div>
<p>もし静的ファイルをサーブしたいなら、以下のようにすれば完成です。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">api ::</span> <span class="dt">Proxy</span> <span class="dt">API</span>
api <span class="fu">=</span> <span class="dt">Proxy</span>

<span class="ot">api' ::</span> <span class="dt">Proxy</span> <span class="dt">API'</span>
api' <span class="fu">=</span> <span class="dt">Proxy</span>

<span class="ot">server ::</span> <span class="dt">Server</span> <span class="dt">API</span>
server <span class="fu">=</span> randomPoint
    <span class="fu">:&lt;|&gt;</span> searchBook

<span class="ot">server' ::</span> <span class="dt">Server</span> <span class="dt">API'</span>
server' <span class="fu">=</span> server
     <span class="fu">:&lt;|&gt;</span> serveDirectory <span class="st">&quot;tutorial/t9&quot;</span>

<span class="ot">app ::</span> <span class="dt">Application</span>
app <span class="fu">=</span> serve api' server'</code></pre></div>
<p>なぜ2つの異なる API type が proxy と server をするのでしょうか。 単純に API type の <code>Raw</code> の部分のために javascript 関数を生成したくないので、<code>Raw</code> エンドポイント なしで <code>API</code> API type のために <code>Proxy</code> が必要です。</p>
<p>haskell 関数を導出する方法に非常に同じように、<code>Servant.JQuery</code> から <code>jsForAPI</code> を呼び出す単純な 関数で javascript を導出できる。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">apiJS ::</span> <span class="dt">String</span>
apiJS <span class="fu">=</span> jsForAPI api</code></pre></div>
<p>この <code>String</code> は2つの javascript 関数を持っている。</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">
<span class="kw">function</span> <span class="fu">getpoint</span>(onSuccess, onError)
{
  <span class="ot">$</span>.<span class="fu">ajax</span>(
    { <span class="dt">url</span>: <span class="st">'/point'</span>
    , <span class="dt">success</span>: onSuccess
    , <span class="dt">error</span>: onError
    , <span class="dt">method</span>: <span class="st">'GET'</span>
    });
}

<span class="kw">function</span> <span class="fu">getbooks</span>(q, onSuccess, onError)
{
  <span class="ot">$</span>.<span class="fu">ajax</span>(
    { <span class="dt">url</span>: <span class="st">'/books'</span> + <span class="st">'?q='</span> + <span class="fu">encodeURIComponent</span>(q)
    , <span class="dt">success</span>: onSuccess
    , <span class="dt">error</span>: onError
    , <span class="dt">method</span>: <span class="st">'GET'</span>
    });
}</code></pre></div>
<p>サーバを始める前に、ファイルへこの <code>String</code> を書く必要があります。<code>api.js</code> は <em>jQuery</em> ライブラリ のコピーとともに <a href="http://hackage.haskell.org/package/js-jquery">js-jquery</a> によって提供されて います。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">writeJSFiles ::</span> <span class="dt">IO</span> ()
writeJSFiles <span class="fu">=</span> <span class="kw">do</span>
  writeFile <span class="st">&quot;getting-started/gs9/api.js&quot;</span> apiJS
  jq <span class="ot">&lt;-</span> readFile <span class="fu">=&lt;&lt;</span> Language.Javascript.JQuery.file
  writeFile <span class="st">&quot;getting-started/gs9/jq.js&quot;</span> jq</code></pre></div>
<p>以上です。<code>dist/build/tutorial/tutorial 9</code> でサーバを動かせます。 <code>http://localhost:8081/</code> で確認できます。 データベースの著者の1人の名前または本の題名の一部を入力すると、上記のメソッドを使って、 pi に近づくことになります。</p>
<div style="text-align: center;">
<p>
<a href="../../tutorial/client.html">Previous page: Deriving Haskell functions to query an API</a>
</p>
<p>
<a href="../../tutorial/docs.html">Next page: Generating documentation for APIs</a>
</p>
</div>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
            -
            <a href="https://github.com/haskell-servant/haskell-servant.github.io">Source</a>
        </div>
    </body>
</html>
