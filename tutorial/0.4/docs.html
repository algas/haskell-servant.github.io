<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Generating documentation from API types - haskell-servant</title>
        <link rel="stylesheet" type="text/css" href="../../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../../">servant</a>
            </div>
            <div id="navigation">
                <a href="../../">Home</a>
                <a href="../../blog.html">Blog</a>
                <a href="../../tutorial">Tutorial</a>
                <a href="../../tips.html">Tips and tricks</a>
                <a href="../../talks.html">Talks</a>
                <a href="https://github.com/haskell-servant/servant">Github</a>
            </div>
        </div>

        <div id="content">
            <h1>Generating documentation from API types</h1>

            
<p>この章のソースは literate haskell file として書かれています。 まずは言語拡張と import が必要です。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DataKinds #-}</span>
<span class="ot">{-# LANGUAGE DeriveGeneric #-}</span>
<span class="ot">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span>
<span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="ot">{-# LANGUAGE TypeOperators #-}</span>
<span class="ot">{-# OPTIONS_GHC -fno-warn-orphans #-}</span>

<span class="kw">module</span> <span class="dt">Docs</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Data.ByteString.Lazy</span> (<span class="dt">ByteString</span>)
<span class="kw">import </span><span class="dt">Data.Proxy</span>
<span class="kw">import </span><span class="dt">Data.Text.Lazy.Encoding</span> (encodeUtf8)
<span class="kw">import </span><span class="dt">Data.Text.Lazy</span> (pack)
<span class="kw">import </span><span class="dt">Network.HTTP.Types</span>
<span class="kw">import </span><span class="dt">Network.Wai</span>
<span class="kw">import </span><span class="dt">Servant.API</span>
<span class="kw">import </span><span class="dt">Servant.Docs</span>
<span class="kw">import </span><span class="dt">Servant.Server</span></code></pre></div>
<p><a href="../../tutorial/server.html">Serving an API</a> モジュールの1つからいくつかを import します。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Server</span> (<span class="dt">Email</span>(..), <span class="dt">ClientInfo</span>(..), <span class="dt">Position</span>(..), <span class="dt">HelloMessage</span>(..),
  server3, emailForClient)</code></pre></div>
<p>クライアントの関数生成のように、ドキュメント生成とは API type の推論と、APIのユーザへのフォーマットとして 示す必要がある全データの抽出を意味しています。</p>
<p>しかし今回は <em>servant</em> を補助しなければなりません。APIについてたくさんのことを推定できるので、 ユーザフレンドリーなAPIの様々な点を記述するのに偶然気づいたり、“ビジネスロジックレベル”で何であるのか 説明できません。 ドキュメント生成のための勉強となるいい例が <code>/position</code>, <code>/hello</code>, <code>/marketing</code> エンドポイントを 使ったウェブサービスです。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">ExampleAPI</span> <span class="fu">=</span> <span class="st">&quot;position&quot;</span> <span class="fu">:&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;x&quot;</span> <span class="dt">Int</span> <span class="fu">:&gt;</span> <span class="dt">Capture</span> <span class="st">&quot;y&quot;</span> <span class="dt">Int</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] Position</span>
      <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;hello&quot;</span> <span class="fu">:&gt;</span> <span class="dt">QueryParam</span> <span class="st">&quot;name&quot;</span> <span class="dt">String</span> <span class="fu">:&gt;</span> <span class="dt">Get</span> <span class="ch">'[JSON] HelloMessage</span>
      <span class="fu">:&lt;|&gt;</span> <span class="st">&quot;marketing&quot;</span> <span class="fu">:&gt;</span> <span class="dt">ReqBody</span> <span class="ch">'[JSON] ClientInfo :&gt; Post '</span>[<span class="dt">JSON</span>] <span class="dt">Email</span>

<span class="ot">exampleAPI ::</span> <span class="dt">Proxy</span> <span class="dt">ExampleAPI</span>
exampleAPI <span class="fu">=</span> <span class="dt">Proxy</span></code></pre></div>
<p><em>servant</em> の例では3つのエンドポイントとそのレスポンスボディがJSONで出力されるので、ウェブサービス上の キャプチャ、パラメータリクエストボディやその他の結合子がどのような影響を与えるかを知ることはできません。 これには手動での操作が必要になります。</p>
<p>キャプチャ、リクエストボディ、レスポンスボディ、クエリパラメータによって、レスポンスにどのような影響を あたえ、どんな値を取りうるかの説明をしなければなりません。上述の例は以下のようになります。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">ToCapture</span> (<span class="dt">Capture</span> <span class="st">&quot;x&quot;</span> <span class="dt">Int</span>) <span class="kw">where</span>
  toCapture _ <span class="fu">=</span>
    <span class="dt">DocCapture</span> <span class="st">&quot;x&quot;</span>                                <span class="co">-- name</span>
               <span class="st">&quot;(integer) position on the x axis&quot;</span> <span class="co">-- description</span>

<span class="kw">instance</span> <span class="dt">ToCapture</span> (<span class="dt">Capture</span> <span class="st">&quot;y&quot;</span> <span class="dt">Int</span>) <span class="kw">where</span>
  toCapture _ <span class="fu">=</span>
    <span class="dt">DocCapture</span> <span class="st">&quot;y&quot;</span>                                <span class="co">-- name</span>
               <span class="st">&quot;(integer) position on the y axis&quot;</span> <span class="co">-- description</span>

<span class="kw">instance</span> <span class="dt">ToSample</span> <span class="dt">Position</span> <span class="dt">Position</span> <span class="kw">where</span>
  toSample _ <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">Position</span> <span class="dv">3</span> <span class="dv">14</span>) <span class="co">-- example of output</span>

<span class="kw">instance</span> <span class="dt">ToParam</span> (<span class="dt">QueryParam</span> <span class="st">&quot;name&quot;</span> <span class="dt">String</span>) <span class="kw">where</span>
  toParam _ <span class="fu">=</span>
    <span class="dt">DocQueryParam</span> <span class="st">&quot;name&quot;</span>                     <span class="co">-- name</span>
                  [<span class="st">&quot;Alp&quot;</span>, <span class="st">&quot;John Doe&quot;</span>, <span class="st">&quot;...&quot;</span>] <span class="co">-- example of values (not necessarily exhaustive)</span>
                  <span class="st">&quot;Name of the person to say hello to.&quot;</span> <span class="co">-- description</span>
                  <span class="dt">Normal</span> <span class="co">-- Normal, List or Flag</span>

<span class="kw">instance</span> <span class="dt">ToSample</span> <span class="dt">HelloMessage</span> <span class="dt">HelloMessage</span> <span class="kw">where</span>
  toSamples _ <span class="fu">=</span>
    [ (<span class="st">&quot;When a value is provided for 'name'&quot;</span>, <span class="dt">HelloMessage</span> <span class="st">&quot;Hello, Alp&quot;</span>)
    , (<span class="st">&quot;When 'name' is not specified&quot;</span>, <span class="dt">HelloMessage</span> <span class="st">&quot;Hello, anonymous coward&quot;</span>)
    ]
    <span class="co">-- mutliple examples to display this time</span>

<span class="ot">ci ::</span> <span class="dt">ClientInfo</span>
ci <span class="fu">=</span> <span class="dt">ClientInfo</span> <span class="st">&quot;Alp&quot;</span> <span class="st">&quot;alp@foo.com&quot;</span> <span class="dv">26</span> [<span class="st">&quot;haskell&quot;</span>, <span class="st">&quot;mathematics&quot;</span>]

<span class="kw">instance</span> <span class="dt">ToSample</span> <span class="dt">ClientInfo</span> <span class="dt">ClientInfo</span> <span class="kw">where</span>
  toSample _ <span class="fu">=</span> <span class="dt">Just</span> ci

<span class="kw">instance</span> <span class="dt">ToSample</span> <span class="dt">Email</span> <span class="dt">Email</span> <span class="kw">where</span>
  toSample _ <span class="fu">=</span> <span class="dt">Just</span> (emailForClient ci)</code></pre></div>
<p>リクエストまたはレスポンス本体として使われる型は、1つ以上の値の例を示す <code>ToSample</code> 型クラスを インスタンス化しなければなりません。<code>Capture</code> と <code>QueryParam</code> はそれぞれ <code>ToCapture</code> と <code>ToParam</code> クラスをインスタンス化しなければなりません。そして名前と上記のコードで書かれているような 引数の具体的な意味についての情報を与えなければなりません。</p>
<p>APIによってdocsを導出できます。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">apiDocs ::</span> <span class="dt">API</span>
apiDocs <span class="fu">=</span> docs exampleAPI</code></pre></div>
<p><code>API</code> は <em>servant-docs</em> によって導出される型です。servant-docs は同じフォーマットでドキュメントを 生成するために web API について必要な情報をすべて保持しています。 <em>servant-docs</em> は <a href="http://en.wikipedia.org/wiki/Markdown">Markdown</a> 出力するドキュメント生成器 しか持ちませんが、<a href="http://hackage.haskell.org/package/servant-pandoc">servant-pandoc</a> パッケージ にはたくさんの便利なフォーマットを使う機能があります。</p>
<p><em>servant</em> のマークダウン pretty printer は <code>markdown</code> という名前の関数です。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">markdown ::</span> <span class="dt">API</span> <span class="ot">-&gt;</span> <span class="dt">String</span></code></pre></div>
<p><code>maekdown apiDocs</code> を見ると、どのように markdown で書かれた API ドキュメントが生成されるかが分かります。</p>
<pre class="text"><code> ## Welcome

 This is our super webservice's API.

 Enjoy!

 ## GET /hello

 #### GET Parameters:

 - name
      - **Values**: *Alp, John Doe, ...*
      - **Description**: Name of the person to say hello to.


 #### Response:

 - Status code 200
 - Headers: []

 - Supported content types are:

     - `application/json`

 - When a value is provided for 'name'

   ```javascript
   {&quot;msg&quot;:&quot;Hello, Alp&quot;}
   ```

 - When 'name' is not specified

   ```javascript
   {&quot;msg&quot;:&quot;Hello, anonymous coward&quot;}
   ```

 ## POST /marketing

 #### Request:

 - Supported content types are:

     - `application/json`

 - Example: `application/json`

   ```javascript
   {&quot;email&quot;:&quot;alp@foo.com&quot;,&quot;interested_in&quot;:[&quot;haskell&quot;,&quot;mathematics&quot;],&quot;age&quot;:26,&quot;name&quot;:&quot;Alp&quot;}
   ```

 #### Response:

 - Status code 201
 - Headers: []

 - Supported content types are:

     - `application/json`

 - Response body as below.

   ```javascript
   {&quot;subject&quot;:&quot;Hey Alp, we miss you!&quot;,&quot;body&quot;:&quot;Hi Alp,\n\nSince you've recently turned 26, have you checked out our latest haskell, mathematics products? Give us a visit!&quot;,&quot;to&quot;:&quot;alp@foo.com&quot;,&quot;from&quot;:&quot;great@company.com&quot;}
   ```

 ## GET /position/:x/:y

 #### Captures:

 - *x*: (integer) position on the x axis
 - *y*: (integer) position on the y axis

 #### Response:

 - Status code 200
 - Headers: []

 - Supported content types are:

     - `application/json`

 - Response body as below.

   ```javascript
   {&quot;x&quot;:3,&quot;y&quot;:14}
   ```
</code></pre>
<p>さらに、ドキュメントについて紹介する章を追加します。<code>apiDocs</code> を生成する方法を微調整するだけです。 <code>wai</code> が求めてるのは <code>Raw</code> エンドポイントなので、文章内容を遅延<code>ByteString</code>型に変えます</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">docsBS ::</span> <span class="dt">ByteString</span>
docsBS <span class="fu">=</span> encodeUtf8
       <span class="fu">.</span> pack
       <span class="fu">.</span> markdown
       <span class="fu">$</span> docsWithIntros [intro] exampleAPI

  <span class="kw">where</span> intro <span class="fu">=</span> <span class="dt">DocIntro</span> <span class="st">&quot;Welcome&quot;</span> [<span class="st">&quot;This is our super webservice's API.&quot;</span>, <span class="st">&quot;Enjoy!&quot;</span>]</code></pre></div>
<p><code>docsWithIntros</code> は <code>DocIntro</code> のリストという追加のパラメータを取ります。 これはどのエンドポイントのドキュメントよりも先に表示されなければなりません。</p>
<p>これで API と API ドキュメントが単純なサーバで動かすことができるようになりました。</p>
<div class="sourceCode"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">DocsAPI</span> <span class="fu">=</span> <span class="dt">ExampleAPI</span> <span class="fu">:&lt;|&gt;</span> <span class="dt">Raw</span>

<span class="ot">api ::</span> <span class="dt">Proxy</span> <span class="dt">DocsAPI</span>
api <span class="fu">=</span> <span class="dt">Proxy</span>

<span class="ot">server ::</span> <span class="dt">Server</span> <span class="dt">DocsAPI</span>
server <span class="fu">=</span> Server.server3 <span class="fu">:&lt;|&gt;</span> serveDocs

  <span class="kw">where</span> serveDocs _ respond <span class="fu">=</span>
          respond <span class="fu">$</span> responseLBS ok200 [plain] docsBS

        plain <span class="fu">=</span> (<span class="st">&quot;Content-Type&quot;</span>, <span class="st">&quot;text/plain&quot;</span>)

<span class="ot">app ::</span> <span class="dt">Application</span>
app <span class="fu">=</span> serve api server</code></pre></div>
<p>このサーバは <code>dist/build/tutorial/tutorial 10</code> で動かすことができます。 <code>/position</code>, <code>/hello</code>, <code>/marketing</code> 以外で API ドキュメントを見ることが出来ます。 <code>serverDocs</code> は3つ以外のエンドポイントがマッチしなくてシステム的に成功するかどうかを試されるからです。 成功の定義は <code>text/plain</code> コンテントタイプと決められた bytestring を返すことです。</p>
<div style="text-align: center;">
<p><a href="../../tutorial/javascript.html">Previous page: Generating javascript functions to query an API</a></p>
</div>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
            -
            <a href="https://github.com/haskell-servant/haskell-servant.github.io">Source</a>
        </div>
    </body>
</html>
